<!DOCTYPE html><html lang="en"><head><title>The Highest-Level Feature of C</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>The Highest-Level Feature of C</h1><p>At first blush this is going to sound ridiculous, but bear with me: the highest-level feature of C is the <code>switch</code> statement.</p><p>As any good low-level language should be, C is designed for transparent compilation. If you take a bit of C source, the corresponding object code emitted by the compiler--even a heavily optimizing compiler--roughly mimics the structure of the original text.</p><p>The <code>switch</code> statement is the only part of the language where you specify an <i>intent</i>, and the choice of how to make that a reality is not only out of your hands, but the resulting code can vary in algorithmic complexity.</p><p>Sure, there are other situations where the compiler can step in and reinterpret things. A <code>for</code> loop known to execute three times can be replaced by three instances of the loop body. In some circumstances, if you're careful not to trip over all the caveats, a loop can be vectorized so multiple elements can be processed in each iteration. None of these are fundamental changes. Your loop is still conceptually a loop, one way or another.</p><p>The possibilities when compiling a <code>switch</code> are much more varied. It can result in a trivial series of <code>if..else</code> statements. It can result in a binary search. Or, if the values are consecutive, a jump table. Or for a complex sequence, some combination of these techniques. If each <code>case</code> simply assigns a different value to the same variable, then it can be implemented as a range check and array lookup. The overall sweep of the solutions, from hundreds of sequential, mispredicted comparisons to a single memory read, is substantial.</p><p>The same principle is what makes pattern matching so useful in Erlang and Haskell. You provide this great, messy bunch of patterns containing a mix of numbers and lists and tuples and "don't care" values. At compile time the commonalities, exceptional cases, and opportunities for table lookups are sorted out, and fairly optimally, too. </p><p>In the compiled code for this bit of Erlang, the tuple size is used for dispatching to the correct line:</p><pre>case Position of
   {X, Y, Dir}       -&gt; ...
   {X, Y, Dir, _, _} -&gt; ...
   {X, Y, _, _}      -&gt; ...
   {X, Y}            -&gt; ...
end</pre><p>The <code>switch</code> statement in C is a signal that even though you could do it yourself, you'd prefer to have the compiler act as a robotic assistant who'll take your spec--a list of values and actions--and write the code for you.</p><p>(If you liked this, you might enjoy <a href="40.html">On Being Sufficiently Smart</a>.)</p><p class="s"><a href="166.html" id="perm">permalink</a> <i>February 14, 2013</i></p><h1>previously</h1><ul><li><a href=165.html>Sympathy for Students in Beginning Programming Classes</a><li><a href=164.html>Trapped by Exposure to Pre-Existing Ideas</a><li><a href=163.html>An Irrational Fear of Files on the Desktop</a><li><a href=162.html>2012 Retrospective</a><li><a href=161.html>Documenting the Undocumentable</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>