<!DOCTYPE html><html lang="en"><head><title>Erlang as a Target for Imperative DSLs</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Erlang as a Target for Imperative DSLs</h1><p>It's easy to show that any imperative program can be implemented functionally.  Or more specifically, that any imperative program can be translated into Erlang.  That doesn't mean the functional version is better or easier to write, of course.</p><p>Take an imperative program that operates on a set of variables.  Put all of those variables into a dictionary called <code>Falafel</code>.  Make every function take <code>Falafel</code> as the first parameter and return a tuple of the form <code>{NewFalafel, OtherValues}</code>.  This is the classic "pass around the state of the global world" approach, except that the topic is so dry that I amuse myself by saying <code>Falafel</code> instead of <code>World</code>.  But I'll go back to the normal terminology now.</p><p>What's awkward is that every time a new version of <code>World</code> is created inside the same function, it needs a new name.  C code like this:</p><pre>color = 57;
width = 205;</pre><p>can be mindlessly translated to Erlang: </p><pre>World2 = dict:store(color, 57, World),
World3 = dict:store(width, 205, World2),</pre><p>That's completely straightforward, yes, but manually keeping track of the current name of the world is messy.  This could be written as:</p><pre>dict:store(width, 205, dict:store(color, 57, World))</pre><p>which has the same potential for programmer confusion when it comes to larger, general cases.  I wouldn't want to write code like this by hand.  But perhaps worrying about the limitations of a human programmer is misguided.  It's easy enough to start with a simple imperative language and generate Erlang code from it.  Or wait, is that cheating?  Or <a href="3.html">admitting that functional programming can be awkward</a>?</p><p>None of this eliminates the issue that <code>dict:store</code> involves a lot of Erlang code, code that's executed for every faux variable update.</p><p>A different angle is to remember that parameters in a tail call are really destructive updates (see <a href="1.html">A Deeper Look at Tail Recursion in Erlang</a>; and I should have said "Tail Calls" instead of "Tail Recursion" when I wrote the title). Arbitrarily messy imperative code can be mechanically translated to Erlang through a simple scheme:</p><blockquote><p>Keep track of the live variables. If a variable is updated, jump to a new function with all live variables passed as parameters and the updated variable replaced with its new value.</p></blockquote><p>Here's some C:</p><pre>total++;
count += total;
row = x * 200 + count;</pre><p>And here's the Erlang version, again mindlessly translated:</p><pre>code_1(X, Total, Count) -&gt;
   code_2(X, Total + 1, Count).
code_2(X, Total, Count) -&gt;
   code_3(X, Total, Count + Total).
code_3(X, Total, Count) -&gt;
   code_4(X, Total, Count, X * 200 + Count).
code_4(X, Total, Count, Row) -&gt;
   ...</pre><p>Hard to read?  Yes.  Bulky at the source code level, too.  But this is highly efficient Erlang, much faster than the dictionary version.  I'd even call it optimal in terms of the BEAM virtual machine.</p><p class="s"><a href="5.html" id="perm">permalink</a> <i>November 18, 2007</i></p><h1>previously</h1><ul><li><a href=4.html>Follow-up to "Admitting that Functional Programming Can Be Awkward"</a><li><a href=3.html>Admitting that Functional Programming Can Be Awkward</a><li><a href=2.html>On the Perils of Benchmarking Erlang</a><li><a href=1.html>A Deeper Look at Tail Recursion in Erlang</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>