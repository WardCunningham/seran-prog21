<!DOCTYPE html><html lang="en"><head><title>Purely Functional Retrogames, Part 3</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Purely Functional Retrogames, Part 3</h1><p>(Read <a href="23.html">Part 1</a> if you missed it.)</p><p>Every entity in a game needs some data to define where it is and what it's doing.  At first thought, a ghost in Pac-Man might be defined by:</p><pre>{X, Y, Color}</pre><p>which looks easy enough, but it's naive.  There needs to be a lot more data than that: direction of movement, behavior state, some base clock values for animation, etc.  And this is just simplistic Pac-Man.  In an imperative or OO language this topic barely deserves thought.  Just create a structure or object for each entity type and add fields as the situation arises.  If the structure eventually contains 50 fields, who cares?  But...</p><p><i>In a functional language, the worst thing you can do is create a large "struct" containing all the data you think you might need for an entity.</i></p><p>First, this doesn't scale well.  Each time you want to "change" a field value, a whole new structure is created.  For Pac-Man it's irrelevant--there are only a handful of entities.  But the key is that if you add a single field, then <i>you're adding overhead across the board to all of the entity processing in your entire program</i>.  The second reason this is a bad idea is that it hides the flow of data.  You no longer know what values are important to a function.  You're just passing in everything, and that makes it harder to experiment with writing simple, obviously correct primitives.  Which is less opaque:</p><pre>step_toward({X,Y}, TargetX, TargetY, Speed) -&gt;
   ...

step_toward(EntityData, TargetX, TargetY, Speed) -&gt;
   ...</pre><p>The advantage of the first one is that you don't need to know what an entity looks like.  You might not have thought that far ahead, which is fine.  You've got a simple function for operating on coordinate pairs which can be used in a variety of places, not just for entity movement. </p><p>If we can't use a big struct, what does an entity look like?  There are undoubtedly many ways to approach this, but I came up with the following scheme.  Fundamentally, an entity is defined by an ID of some sort ("I am one of those fast moving spinning things in Robotron"), movement data (a position and maybe velocity), and the current behavioral state.  At the highest level:</p><pre>{Id, Position, State}</pre><p>Each of these has more data behind it, and that data varies based on the entity type, the current behavior, and so on.  Position might be one of the following:</p><pre>{X, Y}
{X, Y, XVelocity, YVelocity}</pre><p>State might look like:</p><pre>{Name, StartTime, EndTime}
{Name, StartTime, EndTime, SomeStateSpecificData}</pre><p><code>StartTime</code> is so there's a base clock to use for animation or to know how long the current state has been running.  <code>EndTime</code> is the time in the future when the state should end; it isn't needed for all states.</p><p>In my experiments, this scheme got me pretty far.  Everything is very clean at a high level--a three element tuple--and below that there's still the absolute minimum amount of data not only per entity type, but for the exact state that the entity is in.  Compare that to the normal "put everything in a struct" approach, where fields needed only for the "return to center of maze" ghost logic are always sitting there, unused in most states.</p><p>But wait, what about additional state information, such as indicating that a Pac-Man ghost is invulnerable (which is true when a ghost has been reduced to a pair of eyes returning to the center of the maze)?  If you remember <a href="24.html">Part 2</a>, then the parenthetical note in the previous sentence should give it away.  If the ghost is invulnerable when in a specific state, then there's no need for a separate flag.  Just check the state.</p><p><a href="26.html">Part 4</a></p><p class="s"><a href="25.html" id="perm">permalink</a> <i>May 3, 2008</i></p><h1>previously</h1><ul><li><a href=24.html>Purely Functional Retrogames, Part 2</a><li><a href=23.html>Purely Functional Retrogames, Part 1</a><li><a href=22.html>My Road to Erlang</a><li><a href=21.html>Slumming with BASIC Programmers</a><li><a href=20.html>In Praise of Non-Alphanumeric Identifiers</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>