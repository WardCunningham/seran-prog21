<!DOCTYPE html><html lang="en"><head><title>Micro-Build Systems and the Death of a Prominent DSL</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Micro-Build Systems and the Death of a Prominent DSL</h1><p>Normally I don't think about how to rebuild an Erlang project. I just compile a file after editing it--via the <code>c(Filename)</code> shell command--and that's that. With hot code loading there no need for a linking step. Occasionally, such as after upgrading to a new Erlang version, I do this:</p><pre>erlc *.erl</pre><p>which compiles all the <code>.erl</code> files in the current directory.</p><p>But wait a minute. What about checking if the corresponding <code>.beam</code> file has a more recent date than the source and skipping the compilation step for that file? Surely that's gong to be a performance win? Here's the result of fully compiling a mid-sized project consisting of fifteen files:</p><pre>$ time erlc *.erl

real    0m1.912s
user    0m0.945s
sys     0m0.108s</pre><p>That's less than <b>two seconds</b> to rebuild everything. (Immediately rebuilding again takes less than one second, showing that disk I/O is a major factor.)</p><p>Performance is clearly not an issue. Not yet anyway. Mid-sized projects have a way of growing into large-sized projects, and those 15 files could one day be 50. Hmmm...linearly interpolating based on the current project size still gives a time of under six-and-a half-seconds, so no need to panic. But projects get more complex in other ways: custom tools written in different languages, dynamically loaded drivers, data files that need to be preprocessed, Erlang modules generated from data, source code in multiple directories.</p><p>A good start is to move the basic compilation step into pure Erlang:</p><pre>erlang_files() -&gt; [
   "util.erl",
   "http.erl",
   "sandwich.erl",
   "optimizer.erl"
].

build() -&gt;
   c:lc(erlang_files()).</pre><p>where <code>c:lc()</code> is the Erlang shell function for compiling a list of files.</p><p>If you stop and think, this first step is actually a huge step. We've now got a symbolic representation of the project in a form that can be manipulated by Erlang code. <code>erlang_files()</code> could be replaced by searching through the current directory for all files with an <code>.erl</code> extension. We could even do things like skip all files with <code>_old</code> preceding the extension, such as <code>util_old.erl</code>. And all of this is trivially, almost mindlessly, easy.</p><p>There's a handful of things that traditional build systems do. They call shell commands. They manipulate filenames. They compare dates. The fancy ones go through source files and look for included files. These things are a small subset of what you can do in Perl, Ruby, Python, or Erlang. So why <b>not</b> do them in Perl, Ruby, Python, or Erlang?</p><p>I'm pretty sure there's a standard old build system to do this kind of thing, but in a clunky way where you have to be careful whether you use spaces or tabs, remember arcane bits of syntax, remember what rules and macros are built-in, remember tricks involved in building nested projects, remember the differences between the versions that have gone down their own evolutionary paths. I use it rarely enough that I forget all of these details. There are modern variants, too, that trade all of that 1970s-era fiddling for different lists of things to remember. But there's no need.</p><p>It's easier and faster to put together custom, micro-build systems in the high-level language of your choice.</p><p class="s"><a href="49.html" id="perm">permalink</a> <i>September 27, 2009</i></p><h1>previously</h1><ul><li><a href=48.html>The World's Most Mind-Bending Language Has the Best Development Environment</a><li><a href=47.html>A Personal History of Compilation Speed, Part 2</a><li><a href=46.html>The Pure Tech Side is the Dark Side</a><li><a href=45.html>A Personal History of Compilation Speed, Part 1</a><li><a href=44.html>Want People to Use Your Language Under Windows? Do This.</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>