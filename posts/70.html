<!DOCTYPE html><html lang="en"><head><title>A Ramble Through Erlang IO Lists</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>A Ramble Through Erlang IO Lists</h1><p>The IO List is a handy data type in Erlang, but not one that's often discussed in tutorials. It's any binary. Or any list containing integers between 0 and 255. Or any arbitrarily nested list containing either of those two things. Like this:</p><pre>[10, 20, "hello", &lt;&lt;"hello",65&gt;&gt;, [&lt;&lt;1,2,3&gt;&gt;, 0, 255]]</pre><p>The key to IO lists is that you never flatten them. They get passed directly into low-level runtime functions (such as <code>file:write_file</code>), and the flattening happens without eating up any space in your Erlang process. Take advantage of that! Instead of appending values to lists, use nesting instead. For example, here's a function to put a string in quotes:</p><pre>quote(String) -&gt; $" ++ String ++ $".</pre><p>If you're working with IO lists, you can avoid the append operations completely (and the second "++" above results in an entirely new version of <code>String</code> being created). This version uses nesting instead:</p><pre>quote(String) -&gt; [$", String, $"].</pre><p>This creates three list elements no matter how long the initial string is. The first version creates <code>length(String) + 2</code> elements. It's also easy to go backward and un-quote the string: just take the second list element. Once you get used to nesting you can avoid most append operations completely.</p><p>One thing that nested list trick is handy for is manipulating filenames. Want to add a directory name and ".png" extension to a filename? Just do this:</p><pre>[Directory, $/, Filename, ".png"]</pre><p>Unfortunately, filenames in the <code>file</code> module are not true IO lists. You can pass in deep lists, but they get flattened by an Erlang function (<code>file:file_name/1</code>), not the runtime system. That means you can still dodge appending lists in your own code, but things aren't as efficient behind the scenes as they could be. And "deep lists" in this case means <i>only</i> lists, not binaries. Strangely, these deep lists can also contain atoms, which get expanded via <code>atom_to_list</code>.</p><p>Ideally filenames would be IO lists, but for compatibility reasons there's still the need to support atoms in filenames. That brings up an interesting idea: why not allow atoms as part of the general IO list specification? It makes sense, as the runtime system has access to the atom table, and there's a simple correspondence between an atom and how it gets encoded in a binary; 'atom' is treated the same as "atom". I find I'm often calling <code>atom_to_list</code> before sending data to external ports, and that would no longer be necessary.</p><p class="s"><a href="70.html" id="perm">permalink</a> <i>June 13, 2010</i></p><h1>previously</h1><ul><li><a href=69.html>How to Think Like a Pioneer</a><li><a href=68.html>How Much Processing Power Does it Take to be Fast?</a><li><a href=67.html>Rethinking Programming Language Tutorials</a><li><a href=66.html>Living Inside Your Own Black Box</a><li><a href=65.html>A Short Story About Verbosity</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>