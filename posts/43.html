<!DOCTYPE html><html lang="en"><head><title>How to Crash Erlang</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>How to Crash Erlang</h1><p>Now that's a loaded title, and I know some people will immediately see it as a personal slam on Erlang or ammunition for berating the language in various forums.  I mean neither of these.  Crashing a particular language, even so-called safe interpreted implementations, is not particularly challenging.  Running out of memory or stack space are two easy options that work for most languages.  There are pathological cases for regular expressions that may not truly crash, but result in such an extended period of unresponsiveness on large data sets that the difference is moot.  In any language that allows directly linking to arbitrary operating system functions...well, that's just too easy.</p><p>Erlang, offering more complex features than many languages, has some particularly interesting edge cases.</p><p><b>Run out of atoms.</b>  Atoms in Erlang are analogous to symbols in Lisp--that is, symbolic, non-string identifiers that make code more readable, like <code>green</code> or <code>unknown_value</code>--with one exception.  Atoms in Erlang are not garbage collected.  Once an atom has been created, it lives as long as the Erlang node is running.  An easy way to crash the Erlang virtual machine is to loop from 1 to some large number, calling <code>integer_to_list</code> and then <code>list_to_atom</code> on the current loop index.  The atom table will fill up with unused entries, eventually bringing the runtime system to halt.</p><p>Why is this is allowed?  Because garbage collecting atoms would involve a pass over all data in all processes, something the garbage collector <a href="16.html">was specifically designed</a> to avoid.  And in practice, running out of atoms will only happen if you write code that's generating new atoms on the fly.</p><p><b>Run out of processes.</b>  Or similarly, "run out of memory because you've spawned so many processes."  While the sequential core of Erlang leans toward being purely functional, the concurrent side is decidedly imperative.  If you spawn a non-terminating, unlinked process, and manage to lose the process id for it, then it will just sit there, waiting forever.  You've got a process leak.</p><p><b>Flood the mailbox for a process.</b>  This is something that most new Erlang programmers do sooner or later.  One process sends messages to another process without waiting for a reply, and a missing or incorrect pattern in the <code>receive</code> statement causes the receiver to ignore all messages...so they keep piling up until the mailbox fills all available memory, and that's that.  Another reminder that concurrency in Erlang is imperative.</p><p><b>Create too many large binaries in a single process.</b>  Large--greater than 64 byte--binaries are allocated outside of the per-process heap and are reference counted.  The catch is that the reference count indicates how many <i>processes</i> have access to the binary, not how many different pointers there are to it within a process.  That makes the runtime system simpler, but it's not bulletproof.  When garbage collection occurs for a process, unreferenced binaries are deleted, but that's only when garbage collection occurs.  It's possible to create a large process with a slowly growing heap, and create so much binary garbage that the system runs out of memory before garbage collection occurs.  Unlikely, yes, but possible.</p><p class="s"><a href="43.html" id="perm">permalink</a> <i>June 15, 2009</i></p><h1>previously</h1><ul><li><a href=42.html>Digging Deeper into Sufficiently Smartness</a><li><a href=41.html>Let's Take a Trivial Problem and Make it Hard</a><li><a href=40.html>On Being Sufficiently Smart</a><li><a href=39.html>How My Brain Kept Me from Co-Founding YouTube</a><li><a href=38.html>Puzzle Languages</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>