<!DOCTYPE html><html lang="en"><head><title>Alternate Retrocomputing Histories</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Alternate Retrocomputing Histories</h1><p>There's a computer science course that goes like this: First you build an emulator for a fictional CPU. Then you write an assembler for it. Then you close the loop by defining an executable format that the emulator can load and the assembler can generate, and you have a complete, if entirely virtual, development system.</p><p>Of course this project is intended as an educational tool, to gain exposure to hardware and operating systems concepts. When I took that course, the little homemade CPU felt especially hopeless, making an expensive minicomputer slower than an Apple II. Use it to develop games? Not a chance.</p><p>And now, there's <a href="https://en.wikipedia.org/wiki/MAME">MAME</a>.</p><p>The significance of this deserves some thought. All those processors that were once so fast, from the 6809 to the 68000 to the lesser known TMS34010 CPU/GPU combo that powers Mortal Kombat and NBA Jam, being completely duplicated by mere programs. This pretend hardware can, in real-time, reanimate applications always cited as requiring the ultimate performance: high frame rate games. When you look at the results under MAME, the screen full of enticing pixels, that instructions are being decoded and dispatched by a layer of C code isn't something that makes its way through the system and into your mind.</p><p>Maybe that virtual CPU from that college class isn't so crazy any more?</p><p>Now, sure, you could design your own processor and emulate it on a modern desktop or phone. You could even ship commercial software with it. This little foray into alternate retrocomputing histories will result in systems that are orders of magnitude simpler than what we've currently got. Your hundred virtual opcodes is a footnote to the epic volumes of Intel's x86 instruction set manuals. No matter what object code file structure you come up with, it pales in comparison to the Portable Executable Format that's best explained by <a href="https://code.google.com/p/corkami/wiki/PE101?show=content">large posters</a>.</p><p>I wouldn't do that. It's still assembly language, and I don't want to go back down that road.</p><p>The most fascinating part of this thought experiment is that it's possible at all. You can set aside decades of cruft, start anew in a straightforward way, and the result is immediately usable. There's not much personal appeal to a Z80 emulator, but many applications I've written have small, custom-built interpreters in them, and maybe I didn't take them far enough. Is all the complaining about C++ misguided, in that the entire reason for the existence of C++ is so you can write systems that prevent having to use that language?</p><p>(If you liked this, you might enjoy <a href="188.html">Success Beyond the Barrier of Full Understanding</a>.)</p><p class="s"><a href="213.html" id="perm">permalink</a> <i>December 28, 2015</i></p><h1>previously</h1><ul><li><a href=212.html>What Can You Put in a Refrigerator?</a><li><a href=211.html>The Right Thing?</a><li><a href=210.html>Computer Science Courses that Don't Exist, But Should</a><li><a href=209.html>If You Haven't Done It Before, All Bets Are Off</a><li><a href=208.html>Why Doesn't Creativity Matter in Tech Recruiting?</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>