<!DOCTYPE html><html lang="en"><head><title>Purely Functional Retrogames, Part 1</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Purely Functional Retrogames, Part 1</h1><p>When I started looking into functional languages in 1998, I had just come off a series of projects writing video games for underpowered hardware: Super Nintendo, SEGA Saturn, early PowerPC-based Macintoshes without any graphics acceleration.  My benchmark for usefulness was "Can a programming language be used to write complex, performance intensive video games?"   </p><p>After working through basic tutorials, and coming to grips with the lack of destructive updates, I started thinking about how to write trivial games, like Pac-Man or Defender, in a purely functional manner.  Then I realized that it wasn't performance that was the issue, it was much more fundamental.</p><p><i>I had no idea how to structure the most trivial of games without using destructive updates.</i></p><p>Pac-Man is dead simple in any language that fits the same general model as C.  There are a bunch of globals representing the position of Pac-Man, the score, the level, and so on.  Ghost information is stored in a short array of structures.  Then there's an array representing the maze, where each element is either a piece of the maze or a dot.  If Pac-Man eats a dot, the maze array is updated.  If Pac-Man hits a blue ghost, that ghost's structure is updated to reflect a new state.  There were dozens and dozens of Pac-Man clones in the early 1980s, including tiny versions that you could type in from a magazine.</p><p>In a purely functional language, none of this works.  If Pac-Man eats a dot, the maze can't be directly updated.  If Pac-Man hits a blue ghost, there's no way to directly change the state of the ghost.  How could this possibly work?</p><p>That was a long time ago, and I've spent enough time with functional languages to have figured out how to implement non-trivial, interactive applications like video games.  My plan is to cover this information in a short series of entries.  I'm sticking with 8-bit retrogames because they're simple and everyone knows what Pac-Man looks like.  I don't want to use abstract examples involving hypothetical game designs.  I'm also sticking with purely functional programming language features, because that's the challenge.  I know that ML has references and that processes in Erlang can be used to mimic objects, but if you go down that road you might as well be using C.</p><p>The one exception to "purely functional" is that I don't care about trying to make I/O fit a functional model.  In a game, there are three I/O needs: input from the user, a way to render graphics on the screen, and a real-time clock.  Fortunately, these only matter at the very highest level outer loop, one that looks like:</p><pre>repeat forever {
   get user input
   process one frame
   draw everything on the screen
   wait until a frame's worth of time has elapsed
}</pre><p>"Process one frame" is the interesting part.  It takes the current game state and user input as parameters and returns a new game state.  Then that game state can be used for the "draw everything" step.  "Draw everything" can also be purely functional, returning an abstract list of sprites and coordinates, a list that can be passed directly to a lower level, and inherently impure, function that talks to the graphics hardware.</p><p>An open question is "Is being purely functional, even excepting I/O, worthwhile?"  Or is it, as was suggested to me via email earlier this year, the equivalent of writing a novel without using the letter 'e'?</p><p><a href="24.html">Part 2</a></p><p class="s"><a href="23.html" id="perm">permalink</a> <i>April 12, 2008</i></p><h1>previously</h1><ul><li><a href=22.html>My Road to Erlang</a><li><a href=21.html>Slumming with BASIC Programmers</a><li><a href=20.html>In Praise of Non-Alphanumeric Identifiers</a><li><a href=19.html>Five Memorable Books About Programming</a><li><a href=18.html>Back to the Basics of Functional Programming</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>