<!DOCTYPE html><html lang="en"><head><title>Garbage Collection in Erlang</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Garbage Collection in Erlang</h1><p>Given its "soft real time" label, I expected Erlang to use some fancy incremental garbage collection approach.  And indeed, such an approach <a href="http://citeseer.ist.psu.edu/armstrong95one.html">exists</a>, but it's slower than traditional GC in practice (because it touches the entire the heap, not just the live data).  In reality, garbage collection in Erlang is fairly vanilla. Processes start out using a straightforward compacting collector.  If a process gets large, it is automatically switched over to a generational scheme. The generational collector is simpler than in some languages, because there's no way to have an older generation pointing to data in a younger generation (remember, you can't destructively modify a list or tuple in Erlang).</p><p>The key is that garbage collection in Erlang is <i>per process</i>.  A system may have tens of thousands of processes, using a gigabyte of memory overall, but if GC occurs in a process with a 20K heap, then the collector only touches that 20K and collection time is imperceptible.  With lots of small processes, you can think of this as a truly incremental collector. But there's still a lurking worst case in Erlang: What if all of those processes run out of memory more or less in the same wall-clock moment?  And there's nothing preventing an application from using one massive process (such is the case with the <a href="http://wings3d.com">Wings 3D</a> modeller).</p><p>Per-process GC allows a slick technique that can completely prevent garbage collection in some circumstances.  Using <code>spawn_opt</code> instead of the more common <code>spawn</code>, you can specify the initial heap size for a process.  If you know, as discovered through profiling, that a process rapidly grows up to 200K and then terminates, you can give that process an initial heap size of 200K.  Data keeps getting added to the end of the heap, and then before garbage collection kicks in, the process heap is deleted and its contents are never scanned.</p><p>The other pragmatic approach to reducing the cost of garbage collection in Erlang is that lots of data is kept outside of the per-process heaps:</p><p><b>Binaries > 64 bytes.</b>  Large binaries are allocated in a separate heap outside the scope of a process.  Binaries can't, by definition, contain pointers to other data, so they're reference counted.  If there's a 50MB binary loaded, it's guaranteed never to be copied as part of garbage collection.</p><p><b>Data stored in ETS tables.</b>  When you look up key in an ETS table, the data associated with that key is copied into the heap for the process the request originated from.  For structurally large values (say, a tuple of 500 elements) the copy from ETS table space to the process heap may become expensive, but if there's 100MB of total data in a table, there's no risk of all that data being scanned at once by a garbage collector.</p><p><b>Data structure constants.</b> This is <a href="10.html">new</a> in Erlang.</p><p><b>Atom names.</b>  Atom name strings are stored in a separate data area and are not garbage collected.  In Lisp, it's common for symbol names to be stored on the main heap, which adds to garbage collection time.  But that also means that dynamically creating symbols in Lisp is a reasonable approach to some problems, but it's not something you want to do in Erlang.</p><p class="s"><a href="16.html" id="perm">permalink</a> <i>January 6, 2008</i></p><h1>previously</h1><ul><li><a href=15.html>Why Garbage Collection Paranoia is Still (sometimes) Justified</a><li><a href=14.html>Functional Programming Archaeology</a><li><a href=13.html>Would You Bet $100,000,000 on Your Pet Programming Language?</a><li><a href=12.html>Timings and the Punchline</a><li><a href=11.html>Revisiting "Programming as if Performance Mattered"</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>