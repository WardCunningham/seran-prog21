<!DOCTYPE html><html lang="en"><head><title>Don't Be Afraid of Special Cases</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Don't Be Afraid of Special Cases</h1><p>In the body of work on low-level optimization, there's a heavy emphasis on avoiding branches.  Here's a well-known snippet of x86 code which sets eax to the smaller of the two values in eax and ecx:</p><pre>sub ecx, eax
sbb edx, edx
and ecx, edx
add eax, ecx</pre><p>At the CPU hardware level, branches are indeed expensive and messy.  A mispredicted branch empties the entire instruction pipeline, and it can take a dozen or more cycles to get that pipeline full and ticking along optimally again.</p><p>But that's only at the lowest level, and unless you're writing a code generator or a routine that's hyper-sensitive to instruction-level tweaks, like movie compression or software texture mapping, it's doubtful that going out of your way to avoid branches will be significant.  Ignoring efficiency completely, there's still the stigma that code with many conditionals in it, to handle special cases, is inherently ugly, even poorly engineered. </p><p>That's the programmer's code-centric view.  The user of an application isn't thinking like that at all.  He or she is thinking purely about ease of use, and ugly is when a program displays "1 files deleted" (or even "1 file(s) deleted"), or puts up a dialog box that crosses between two monitors, making it unreadable.</p><p>In 1996-7 I wrote a game called "Bumbler" for the Mac.  (Yes, I've brought this up before, but that's because I spent 18 months as a full-time indie game developer, which was more valuable--and probably just as expensive--as getting another college degree.)  Bumbler is an insect-themed shooter that takes place on a honeycomb background.  When an insect is killed, the honeycomb behind it fills with honey.  Every Nth honeycomb fills with pulsing red "special honey," which you can fly over and something special happens.  Think "power-ups."</p><p>The logic driving event selection isn't just a simple random choice between the seven available special honey effects.  I <i>could</i> have done that, sure, but it would have been a lazy decision on my part, one that would have hurt the game in noticeable ways.  Here are some of the special honey events and the special cases involved:</p><p><b>Create hole.</b>  This added a hole to the honeycomb that insects could crawl out of, the only negative special honey event.  During play testing I found out that if a hole was created near the player start position, the player would often collide with an insect crawling out of it at the start of a life.  So "create hole" was disallowed in a rectangular region surrounding the player start.  It was also not allowed if there were already a certain number of holes in the honeycomb, to avoid too much unpredictability.</p><p><b>Release flowers.</b>  This spawned bonus flowers from each of the holes in the honeycomb.  But if there were already many flowers on the screen, then the player could miss this entirely, and it looked like nothing happened.  If there were more than X flowers on the screen, this event was removed from the list of possibilities.</p><p><b>Flower magnet.</b> This caused all the flowers on the screen to flash yellow and home on in the player.  This was good, because you got more points, but bad because the flowers blocked your shots.  To make this a rare event, one that the player would be surprised by, it was special-cased to not occur during the first ten or so levels, plus once it happened it couldn't be triggered again for another five levels.  Okay, that's two special cases.  Additionally, if there weren't any flowers on the screen, then it looked like nothing happened, and if there were only a few flowers, it was underwhelming.  So this event was only allowed if there were a lot of flowers in existence.</p><p>All of these cases improved the game, and play testing supported them.  Did they make the code longer and arguably uglier?  Yes.  Much more so because I wasn't using a language that encourages adding special cases in an unobtrusive way.  One of the advantages to a language with pattern matching, like Erlang or Haskell or ML, is that there's a programing assistant of sorts, one that takes your haphazard lists of special cases--patterns--and turns then into an optimal sequence of old-fashioned conditionals, a jump table, or even a hash table.</p><p class="s"><a href="27.html" id="perm">permalink</a> <i>May 25, 2008</i></p><h1>previously</h1><ul><li><a href=26.html>Purely Functional Retrogames, Part 4</a><li><a href=25.html>Purely Functional Retrogames, Part 3</a><li><a href=24.html>Purely Functional Retrogames, Part 2</a><li><a href=23.html>Purely Functional Retrogames, Part 1</a><li><a href=22.html>My Road to Erlang</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>