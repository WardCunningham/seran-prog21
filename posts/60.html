<!DOCTYPE html><html lang="en"><head><title>What to do About Erlang's Records?</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>What to do About Erlang's Records?</h1><p>The second most common complaint about Erlang, right after confusion about commas and semicolons as separators, is about records. Gotta give those complainers some credit, because they've got taste. Statically defined records are out of place in a highly dynamic language. There have been various proposals over the years, including Richard O'Keefe's abstract syntax patterns and Joe Armstrong's structs. Getting one of those implemented needs the solid support of the Erlang system maintainers, and it's understandably difficult to commit to such a sweeping change to the language. So what are the alternatives to records that can be used right now?</p><p>To clarify, I'm really talking about smallish, purely functional <a href="53.html">dictionaries</a>. For large amounts of data there's already the <code>gb_trees</code> module, plus several others with similar purposes.</p><p>In Python, a technique I often use is to return a small dictionary with a couple of named values in it. I could use a tuple, but a dictionary removes the need to worry about order. This is straightforward in Erlang, too:</p><pre>fun(length) -&gt; 46;
   (width)  -&gt; 17;
   (color)  -&gt; sea_green
end.</pre><p>Getting the value corresponding to a key is easy enough:</p><pre>Result(color)</pre><p>This is handy, but only in certain situations. One shortcoming is that there's no way to iterate through the keys. Well, there's this idea:</p><pre>fun(keys)   -&gt; [length, width, color];
   (length) -&gt; 46;
   (width)  -&gt; 17;
   (color)  -&gt; sea_green
end.</pre><p>Now there's a way to get a list of keys, but there's room for error: each key appears twice in the code. The second issue is there's no simple way to take one dictionary and create a new one with a value added or removed. This road is becoming messy to go down, so here's more data-driven representation:</p><pre>[{length, 46}, {width, 17}, {color, sea_green}]</pre><p>That's just a list of key/value pairs, which is searchable via the fast, written-in-C function <code>lists:keyfind</code>. New values can be appended to the head of the list, and there are other functions in the <code>lists</code> module for deleting and replacing values. Iteration is also easy: it's just a list.</p><p>We still haven't bettered records in all ways. A big win for records, and this is something few purely functional data structures handle well, is the ability to create a new version where <em>multiple</em> keys get different values. For example, start with the above list and create this:</p><pre>[{length, 200}, {width, 1400}, {color, sea_green}]</pre><p>If we knew that only those three keys were allowed, fine, but that's cheating. The whole point of dictionaries is that we can put all sorts of stuff in there, and it doesn't change how the dictionary is manipulated. The general solution is to delete all the keys that should have new values, then insert the new key/value pairs at the head of the list. Or step through the list and see if the current key is one that has a new value and replace it. These are not linear algorithms, unfortunately. And you've got the same problem if you want to change multiple values in a <code>gb_tree</code> at the same time.</p><p>What I've been using, and I admit that this isn't perfect, is the key/value list approach, but forcing the lists to be sorted.This allows the original list and a list of changes to be merged together in linear time. The downside is that I have to remember to keep a literal list in sorted order (or write a parse transform to do this for me).</p><p>There's <em>still</em> one more feature of records that can't be emulated: extracting / comparing values using Erlang's standard pattern matching capabilities. It's not a terrible omission, but there's no way to dodge this one: it needs compiler and runtime system support.</p><p class="s"><a href="60.html" id="perm">permalink</a> <i>January 30, 2010</i></p><h1>previously</h1><ul><li><a href=59.html>Nothing Like a Little Bit of Magic</a><li><a href=58.html>Flickr as a Business Simulator</a><li><a href=57.html>No Comment</a><li><a href=56.html>The Recovering Programmer</a><li><a href=55.html>Follow-up to "Functional Programming Doesn't Work"</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>