<!DOCTYPE html><html lang="en"><head><title>Tricky When You Least Expect It</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Tricky When You Least Expect It</h1><p>Here's a problem: You've got a satellite dish that can be rotated to any absolute angle from 0 to 360 degrees. If you think of the dish as being attached to a pole sticking out of the ground, that's what the dish rotates around. Given a starting angle and a desired angle, how many degrees do you rotate the dish by?</p><p>An example should clarify this. If the initial angle is 0 degrees, and the goal is to be at 10 degrees, that's easy. You rotate by 10 degrees. If you're at 10 degrees and you want to end up at 8 degrees, then rotate -2 degrees. It looks at lot like all you have to do is subtract the starting angle from the ending angle, and that's that.</p><p>But if the starting angle is 10 and the ending angle is 350...hmmm. 350 - 10 = 340, but that's the long way around. No one would do that. It makes more sense to rotate by -20 degrees. With this in mind and some experimenting, here's a reasonable looking solution (in Erlang, but it could easily be any language):</p><pre>angle_diff(Begin, End) -&gt;
   D = End - Begin,
   DA = abs(D),
   case DA &gt; 180 of
      true -&gt; -(360 - DA);
      _ -&gt; D
   end.</pre><p>It seems to cover some quickie test cases, including those listed above. Now try <code>angle_diff(270, 0)</code>. The expected answer is 90. But this function returns -90. Oops.</p><p>This is starting to sound like the introduction to a book by <a href="http://www.cs.utexas.edu/users/EWD/">Dijkstra</a>. He'd have called this problem solving method "guessing," and it's hard to disagree with that assessment. When I run into problems like this that look so simple, and I feel like I'm randomly poking at them to get the right answers, I'm always surprised. So many messy problems are solved as part of the core implementation or standard library in most modern languages, that it's unusual to run into something this subtle.</p><p>In Python or Erlang I never worry about sorting, hash functions, heap management, implementing regular expressions, fancy string comparison algorithms such as Boyer-Moore, and so on. Most of the time I write fairly straightforward code that's just basic logic and manipulation of simple data structures. Behind the scenes, that code is leaning heavily on technically difficult underpinnings, but that doesn't change how pleasant things are most of the time. Every once in a while, though, the illusion of all the hard problems being solved for me is shattered, and I run into something that initially seems trivial, yet it takes real effort to work out a correct solution.</p><p>Here's a version of the <code>angle_diff</code> function that handles the cases the previous version didn't:</p><pre>angle_diff(Begin, End) -&gt;
   D = End - Begin,
   DA = abs(D),
   case {DA &gt; 180, D &gt; 0} of
      {true, true} -&gt; DA - 360;
      {true, _}    -&gt; 360 - DA;
      _ -&gt; D
   end.</pre><p>Don't be surprised if it takes some thought to determine if this indeed handles all cases.</p><p>There's now a <a href="96.html">follow-up</a>.</p><p>(If you liked this, you might like <a href="41.html">Let's Take a Trivial Problem and Make it Hard</a>.)</p><p class="s"><a href="71.html" id="perm">permalink</a> <i>June 29, 2010</i></p><h1>previously</h1><ul><li><a href=70.html>A Ramble Through Erlang IO Lists</a><li><a href=69.html>How to Think Like a Pioneer</a><li><a href=68.html>How Much Processing Power Does it Take to be Fast?</a><li><a href=67.html>Rethinking Programming Language Tutorials</a><li><a href=66.html>Living Inside Your Own Black Box</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>