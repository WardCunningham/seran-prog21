<!DOCTYPE html><html lang="en"><head><title>Coding as Performance</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Coding as Performance</h1><p>I want to talk about performance coding.  Not coding for <b>speed</b>, but coding <b>as</b> performance, a la <a href="http://en.wikipedia.org/wiki/Live_coding">live coding</a>.  Okay, I don't really want to talk about that either, as it mostly involves audio programming languages used for on-the-fly music composition, but I like the principle of it: writing programs very quickly, in the timescale of TV show or movie rather than the years it can take to complete a commercial product.  Take any book on agile development or extreme programming and replace "weeks" with "hours" and "days" with "minutes."</p><p>Think of it in terms of a co-worker or friend who comes to you with a problem, something that could be done by hand, but would involve much repetitive work ("I've got a big directory tree, and I need a list of the sum total sizes of all files with the same root names, so hello.txt, hello.doc, and hello.whatever would just show in the report as 'hello', followed by the total size of those three files").  If you can write a program to solve the problem in less time than the tedium of slogging through the manual approach, then you win.  There's no reason to limit this game to this kind of problem, but it's a starting point.</p><p>Working at this level, the difference between gut instinct and proper engineering becomes obvious.  The latter always seems to involve additional time--architecture, modularity, code formatting, interface specification--which is exactly what's in short supply in coding as performance.  Imagine you want to plant a brand new vegetable garden somewhere in your yard, and the first task is to stake out the plot.  Odds are good that you'll be perfectly successful by just eyeballing it, hammering a wooden stake at one corner, and using it as a reference.  Or you could be more formal and use a tape measure.  The ultimate, guaranteed correct solution is to hire a team of surveyors to make sure the distances are exact and the sides perfectly parallel.  But really, who would do that?</p><p>(And if you're thinking "not me," consider people like myself who've grepped a two-hundred megabyte XML file, because it was easier than remembering how to use the available XML parsing libraries.  If your reaction is one of horror because I clearly don't understand the whole purpose of using XML to structure data, then there you go.  You'd hire the surveyors.)</p><p>You can easily spot the programming languages designed for projects operating on shorter timescales. Common, non-trivial operations are built-in, like regular expressions and matrix math (as an aside, the original BASIC language from the 1960s had matrix operators).  Common functions--reading a file, getting the size of a file--don't require importing libraries after you've managed to remember that getting the size of a file isn't a core operation that's in the "file" library and is instead in "os:file:filesize" or wherever the hierarchical-thinking author put it.  But really, any language of the Python or Ruby class is going to be fine.  The big wins are having an interactive read / evaluate / print loop, zero compilation time, and data structures that don't require thinking about low-level implementation details.</p><p>What matter just as much are <b>visualization tools</b>, so you can avoid the classic pitfall of engineering something for weeks or months only to finally realize that you didn't understand the problem and engineered the wrong thing. (Students of <a href="http://www.cs.utexas.edu/users/EWD/">Dijkstra</a> are ready with some good examples of math problems where attempting to guess an answer based on a drawing gives hopelessly incorrect answers, but I'll pretend I don't see them, there in the back, frantically waving their arms.)</p><p>I once used an 8-bit debugger with an interrupt-driven display.  Sixty times per second, the display was updated.  This meant that memory dumps were <b>live</b>.  If a running program constantly changed a value, that memory location showed as blurred digits on the screen.  You could also see numbers occasionally flick from 0 to 255, then back later.  Static parts of the screen meant nothing was changing there.  This sounds simple, but wow was it useful for accidentally spotting memory overruns and logic errors.  I often never suspected a problem, and I wouldn't haven even known what to look for, but found an error just by seeing movement or patterns in a memory dump that didn't look right.</p><p>A modern visualization tool I can't live without is <a href="http://www.weitz.de/regex-coach/">RegEx Coach</a>. I always try out regular expressions using it before copying them over to my Perl or Python scripts.  When I make an error, I <b>see</b> it right away.  That prevents situations where the rest of my program is fine, but a botched regular expression isn't pulling in exactly the data I'm expecting.</p><p>The <a href="http://jsoftware.com">J language</a> ships with some great visualization tools.  Arguably it's the nicest programming environment I've ever used, even though I go back and forth about whether J itself is brilliant or insane.  There's a standard library module which takes a matrix and displays it as a grid of colors.  Identical values use the same color.  Simplistic?  Yes.  But this display format makes patterns and anomalies jump out of the screen.  If you're thinking that you don't write code that involves matrix math, realize that matrices are native to J and you can easily put all sorts of data into a matrix format (in fact, the preferred term for a matrix in J is the more casual "table").</p><p>J also has a similar tool that mimics a spreadsheet display.  Pass in data, and up pops what looks like an Excel window, making it easy to view data that is naturally columnar.  It's easier than dumping values to an HTML file or the old-fashioned method of debug printing a table using a fixed-width font.  There's also an elaborate module for graphing data; no need to export it to a file and use a standalone program.</p><p>I'm hardly suggesting that everyone--or anyone--switch over to J.  It's not the language semantics that matter so much as tools that are focused on interactivity, on working through problems quickly.  And the realization that it is valid to get an answer without always bringing the concerns of software engineering--and the time penalty that comes with them--into the picture.</p><p class="s"><a href="28.html" id="perm">permalink</a> <i>May 31, 2008</i></p><h1>previously</h1><ul><li><a href=27.html>Don't Be Afraid of Special Cases</a><li><a href=26.html>Purely Functional Retrogames, Part 4</a><li><a href=25.html>Purely Functional Retrogames, Part 3</a><li><a href=24.html>Purely Functional Retrogames, Part 2</a><li><a href=23.html>Purely Functional Retrogames, Part 1</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>