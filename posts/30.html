<!DOCTYPE html><html lang="en"><head><title>Want to Write a Compiler? Just Read These Two Papers.</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Want to Write a Compiler? Just Read These Two Papers.</h1><p>Imagine you don't know <i>anything</i> about programming, and you want learn how to do it.  You take a look at Amazon.com, and there's a highly recommended set of books by Knute or something with a promising title, <i>The Art of Computer Programming</i>, so you buy them.  Now imagine that it's more than just a poor choice, but that <b>all</b> the books on programming are at written at that level.</p><p>That's the situation with books about writing compilers.</p><p>It's not that they're bad books, they're just too broadly scoped, and the authors present so much information that it's hard to know where to begin.  Some books are better than others, but there are still the thick chapters about converting regular expressions into executable state machines and different types of grammars and so on. After slogging through it all you will have undoubtedly expanded your knowledge, but you're no closer to actually writing a working compiler.</p><p>Not surprisingly, the opaqueness of these books has led to the myth that compilers are hard to write.</p><p>The best source for breaking this myth is Jack Crenshaw's series, <a href="http://compilers.iecc.com/crenshaw/">Let's Build a Compiler!</a>, which started in 1988.  This is one of those gems of technical writing where what's assumed to be a complex topic ends up being suitable for a first year programming class.  He focuses on compilers of the Turbo Pascal class: single pass, parsing and code generation are intermingled, and only the most basic of optimizations are applied to the resulting code.  The original tutorials used Pascal as the implementation language, but there's a C version out there, too.  If you're truly adventurous, Marcel Hendrix has done a <a href="http://home.iae.nl/users/mhx/crenshaw/tiny.html">Forth translation</a> (and as Forth is an interactive language, it's easier to experiment with and understand than the C or Pascal sources).</p><p>As good as it is, Crenshaw's series has one major omission: there's no internal representation of the program at all.  That is, no abstract syntax tree.  It is indeed possible to bypass this step if you're willing to give up flexibility, but the main reason it's not in the tutorials is because manipulating trees in Pascal is out of sync with the simplicity of the rest of the code he presents.  If you're working in a higher level language--Python, Ruby, Erlang, Haskell, Lisp--then this worry goes away.  It's trivially easy to create and manipulate tree-like representations of data.  Indeed, this is what Lisp, Erlang, and Haskell were designed for.</p><p>That brings me to <a href="http://www.cs.indiana.edu/~dyb/pubs/nano-jfp.pdf">A Nanopass Framework for Compiler Education</a> [PDF] by Sarkar, Waddell, and Dybvig.  The details of this paper aren't quite as important as the general concept:  a compiler is nothing more than a series of transformations of the internal representation of a program.  The authors promote using <b>dozens or hundreds of compiler passes</b>, each being as simple as possible.  Don't combine transformations; keep them separate.  The framework mentioned in the title is a way of specifying the inputs and outputs for each pass.  The code is in Scheme, which is dynamically typed, so data is validated at runtime.</p><p>After writing a compiler or two, then go ahead and plunk down the cash for the infamous <a href="http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">Dragon Book</a> or one of the alternatives.  Maybe.  Or you might not need them at all.</p><p class="s"><a href="30.html" id="perm">permalink</a> <i>June 29, 2008</i></p><h1>previously</h1><ul><li><a href=29.html>A Spellchecker Used to Be a Major Feat of Software Engineering</a><li><a href=28.html>Coding as Performance</a><li><a href=27.html>Don't Be Afraid of Special Cases</a><li><a href=26.html>Purely Functional Retrogames, Part 4</a><li><a href=25.html>Purely Functional Retrogames, Part 3</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>