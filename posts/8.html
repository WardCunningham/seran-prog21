<!DOCTYPE html><html lang="en"><head><title>Deriving Forth</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Deriving Forth</h1><p>When most programmers hear a mention of <a href="http://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a>, assuming they're familiar with it at all, a series of memory fragments surface: stack, Reverse Polish Notation, SWAPping and DUPlicating values.  While the stack and RPN are certainly important to Forth, they don't describe essence of how the language actually works.</p><p>As an illustration, let's write a program to decode modern coffee shop orders.  Things like:</p><blockquote><p>I'd like a grande skinny latte</p></blockquote><p>and</p><blockquote><p>Gimme a tall mocha with an extra shot to go</p></blockquote><p>The catch here is that we're not allowed to write a master parser for this, a program that slurps in the sentence and analyzes it for meaning.  Instead, we can only look at <i>a single word at a time</i>, starting from the left, and each word can only be examined once--no rewinding.</p><p>To get around this arbitrary-seeming rule, each word (like "grande") will have a small program attached to it.  Or more correctly, each word is the <i>name</i> of a program.  In the second example above, first the program called <code>gimme</code> is executed, then <code>a</code>, then <code>tall</code>, and so on.</p><p>Now what do each of these programs do? Some words are clearly noise: I'd, like, a, an, to, with. The program for each of these words simply returns immediately.  "I'd like a," which is three programs, does absolutely nothing.</p><p>Now the first example ("i'd like a grande skinny latte"), ignoring the noise words, is "grande skinny latte."  Three words.  Three programs.  <code>grande</code> sets a <code>Size</code> variable to 2, indicating large.  Likewise, <code>tall</code> sets this same variable to 1, and <code>short</code> sets it to 0.  The second program, <code>skinny</code>, sets a <code>Use_skim_milk</code> flag to true.  The third program, <code>latte</code>, records the drink name in a variable we'll call <code>Drink_type</code>.</p><p>To use a more concise notation, here's a list of the programs for the second example:</p><pre>gimme -&gt; return
a     -&gt; return
tall  -&gt; Size = 1
mocha -&gt; Drink_type = 1
with  -&gt; return
extra -&gt; return
shot  -&gt; Extra_shot = true
to    -&gt; return
go    -&gt; To_go = true</pre><p>When all of these programs have been executed, there's enough data stored in a handful of global variables to indicate the overall drink order, and we managed to dodge writing a real parser.  Almost.  There still needs to be one more program that looks at <code>Drink_type</code> and <code>Size</code> and so on.  If we name that program <code>EOL</code>, then it executes after all the other programs, when end-of-line is reached.  We can even handle rephrasings of the same order, like "mocha with an extra shot, tall, to go" with exactly the same code. </p><p>The process just described is the underlying architecture of Forth: a dictionary of short programs.  In Forth-lingo, each of these named programs is called a <b>word</b>.  The main loop of Forth is simply an interpreter: read the next bit of text delimited by spaces, look it up in the dictionary, execute the program associated with it, repeat.  In fact, even the Forth compiler works like this.  Here's a simple Forth definition:</p><pre>: odd? 1 and ;</pre><p>The colon is a word too, and the program attached to it first reads the next word from the input and creates a dictionary entry with that name.  Then it does this: read the next word in the input, if the word is a semicolon then generate a return instruction and stop compiling, otherwise look up the word in the dictionary, compile a call to it, repeat.</p><p>So where do stacks and RPN come into the picture?  Our coffee shop drink parser is simple, but it's a front for a jumble of variables behind the scenes.  If you're up for some inelegant code, you could do math with the same approach.  "5 + 3" is three words:</p><pre>5   -&gt; Value_1 = 5
+   -&gt; Operation = add
3   -&gt; Value_2 = 3
EOL -&gt; Operation(Value_1, Value_2)</pre><p>but this is clunky and breaks down quickly.  A stack is a good way to keep information flowing between words, maybe the best way, but you could create a dictionary-based language that didn't use a stack at all.  Each function in Backus's FP, for example, creates a value or data structure which gets passed to the next function in sequence.  There's no stack. </p><p>Finally, just to show that my fictional notation is actually close to real Forth, here's a snippet of code for the drink decoder:</p><pre>variable Size
variable Type
: short   0 Size ! ;
: tall    1 Size ! ;
: grande  2 Size ! ;
: latte   0 Type ! ;
: mocha   1 Type ! ;</pre><p class="s"><a href="8.html" id="perm">permalink</a> <i>December 6, 2007</i></p><h1>previously</h1><ul><li><a href=7.html>Trapped! Inside a Recursive Data Structure</a><li><a href=6.html>Sending Modern Languages Back to 1980s Game Programmers</a><li><a href=5.html>Erlang as a Target for Imperative DSLs</a><li><a href=4.html>Follow-up to "Admitting that Functional Programming Can Be Awkward"</a><li><a href=3.html>Admitting that Functional Programming Can Be Awkward</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>