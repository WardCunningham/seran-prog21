<!DOCTYPE html><html lang="en"><head><title>Functional Programming Went Mainstream Years Ago</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Functional Programming Went Mainstream Years Ago</h1><p>In school and early in my programming career I must have written linked-list handling code fifty times.  Those were the days of Pascal and vanilla C.  I didn't have the code memorized either, because there were too many variations:  singly-linked list, singly-linked list with dummy head and tail nodes, doubly-linked list, doubly-linked list with dummy head and tail nodes.  Insertion and deletion routines for each of those.  I worked out the pointer manipulation logic each time I rewrote them.  Good thing, too, because the AP Computer Science exam was chock full of linked-list questions.</p><p>Early functional languages like <a href="http://en.wikipedia.org/wiki/Hope_(programming_language)">Hope</a> and <a href="http://en.wikipedia.org/wiki/Miranda_(programming_language)">Miranda</a> seemed like magic in comparison.  Not only were lists built into those languages, but there was no manual fiddling with pointers or memory <b>at all</b>.  Even more so, the entire concept of memory as the most precious of resources, one to be lovingly arranged and conserved, was absent.  That's not to say that memory was free and infinite, but it was something fluid and changing.  A temporary data structure was created and used transiently, with no permanent cost.</p><p>All of this magic is nothing new in currently popular programming languages.  Fifteen years ago you could say:</p><pre>print join ',', @Items</pre><p>in Perl, taking an arbitrarily long list of arbitrarily long strings, and building an entirely new string consisting of the elements of <code>@Items</code> separated by commas.  Once <code>print</code> is finished with that string, it disappears.  At a low level this is a serious amount of work, all in the name of temporary convenience.  I never would have dared something so cavalier in Turbo Pascal. And yet it opens the door to what's essentially a functional style: creating new values rather than modifying existing ones. You can view a Perl (or Python or Ruby or Lua or Rebol) program as a series of small functional programs connected by a lightweight imperative program.</p><p>But there's more to functional programming than a disassociation from the details of memory layout.  What about higher order functions and absolute purity and monads and elaborate type systems and type inference?  Bits of those already exist in decidedly non-functional languages.  <a href="http://hop.perl.plover.com/">Higher Order Perl</a> is a great book.  Strings are immutable in Python.  Various forms of lambda functions are available in different languages, as are list comprehensions.</p><p>Still, the purists proclaim, it's not enough.  Python is not a replacement for Haskell.  But does it matter?  90% of the impressive magic from early functional languages has been rolled into mainstream languages.  That last 10%, well, it's not clear that anyone is really wanting it or that the benefits are actually there.  Purity has some advantages, but it's so convenient and useful to directly modify a dictionary in Python.  Fold and map are beautiful, but they work just as well in the guise of a foreach loop.</p><p>The answer to "When will Haskell finally go mainstream?" is "most of it already has."</p><p class="s"><a href="31.html" id="perm">permalink</a> <i>July 6, 2008</i></p><h1>previously</h1><ul><li><a href=30.html>Want to Write a Compiler? Just Read These Two Papers.</a><li><a href=29.html>A Spellchecker Used to Be a Major Feat of Software Engineering</a><li><a href=28.html>Coding as Performance</a><li><a href=27.html>Don't Be Afraid of Special Cases</a><li><a href=26.html>Purely Functional Retrogames, Part 4</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>