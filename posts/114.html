<!DOCTYPE html><html lang="en"><head><title>Papers from the Lost Culture of Array Languages</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Papers from the Lost Culture of Array Languages</h1><p>2012 is the 50th anniversary of Ken Iverson's <i>A Programming Language</i>, which described the notation that became APL (even though a machine executable version of APL didn't exist yet). Since then there's been APL2, Nial, A+, K, Q, and other array-oriented languages. Iverson (1920-2004) teamed with Roger Hui to create a modern successor to APL, tersely named J, in the late 1980s.</p><p>The culture of array languages is a curious one. Though largely functional, array languages represent a separate evolutionary timeline from the lambda calculus languages like Miranda and Haskell. (Trivia: The word <i>monad</i> is an important term in both Haskell and J, but has completely different meanings.) Most strikingly, while Haskell was more of a testbed for functional language theorists that eventually became viable for commercial products, array languages found favor as serious development tools early on. Even today, K is used to analyze large data sets, such as from the stock market. J is used in actuarial work.</p><p><a href="http://www.jsoftware.com/papers/tot.htm">Notation as a Tool of Thought</a>, Ken Iverson's 1979 Turing Award Lecture, is the most widely read paper on APL. Donald McIntyre (1923-2009) explored similar ideas in <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.6185&amp;rep=rep1&amp;type=pdf">Language as an Intellectual Tool: From Hieroglyphics to APL</a>. When I first learned of McIntyre's paper roughly ten years ago, it wasn't available on the web. I inquired about it via email, and he said he'd see if he or one of his acquaintances had a copy they could send to me. A week later I received an envelope <i>from Ken Iverson</i> (!) containing non-photocopied reprints of Hieroglyphics and his own <a href="http://www.jsoftware.com/papers/APLPersonalView.htm">A Personal View of APL</a>. I still have both papers in the original envelope.</p><p>Donald McIntyre also wrote <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.98.3105&amp;rep=rep1&amp;type=pdf">The Role of Composition in Computer Programming</a>, which is mind-melting. (Note that it uses an earlier version of J, so you can't always just cut and paste into the J interpreter.)</p><p>There's a touch of melancholy to this huge body--fifty years' worth--of ideas and thought. Fifty years of a culture surrounding a paradigm that's seen as an oddity in the history of computing. Even if you found the other papers I've mentioned to be so many unintelligible squiggles, read Keith Smillie's <a href="http://webdocs.cs.ualberta.ca/~smillie/Jpage/MyLife.pdf">My Life with Array Languages</a>. It covers a thirty-seven year span of programming in APL, Nial, and J that started in 1968.</p><p>(If you liked this, you might enjoy <a href="30.html">Want to Write a Compiler? Just Read These Two Papers.</a>)</p><p class="s"><a href="114.html" id="perm">permalink</a> <i>October 17, 2011</i></p><h1>previously</h1><ul><li><a href=113.html>The Revolution is Personal</a><li><a href=112.html>Optimization on a Galactic Scale</a><li><a href=111.html>Greetings from the Bottom of the Benchmarks</a><li><a href=110.html>Beyond Empty Coding</a><li><a href=109.html>Boldness and Restraint</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>