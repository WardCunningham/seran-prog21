<!DOCTYPE html><html lang="en"><head><title>Dynamic Everything Else</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Dynamic Everything Else</h1><p>Static vs. dynamic typing is one of those recurring squabbles that you should immediately run away from. None of the arguments matter, because there are easy to cite examples of big, famous applications written using each methodology. Then there are confusing cases like large C++ apps that use dynamically typed Lua for scripting. And right about now, without fail, some know-it-all always points out that dynamic typing is really a subset of static typing, which is a lot like defining a liberal as a conservative who holds liberal views, and nothing worthwhile comes from this line of reasoning.</p><p>I have no interest in the static vs. dynamic typing dispute. What I want is dynamic everything else.</p><p>Sitting in front of me is a modern, ultra-fast MacBook Pro. I know it can create windows full of buttons and checkboxes and beautifully rendered text, because I see those things in every app I use. I should be able to start tapping keys and, a command or two later, up pops a live OS X window that's draggable and receives events. I should be able to add controls to that window in a playful sort of way. Instead I have to create an XCode project (the first obstacle to creative fiddling), compile and run to see what I'm doing (the second), then quit and re-run it for each subsequent change (the third).</p><p>There's an impressive system for rendering shapes and curves and fonts under OS X. Like the window example above, I can't interactively experiment with these capabilities either. I end up using a vector-based image editor, but the dynamism goes away when I save what I've created and load it into a different app. Why must the abilities to grab curves and change font sizes be lost when I export? Why can't the editing features be called forth for any image made of vectors?</p><p>I know how to solve these problems. They involve writing custom tools, editors, and languages. Switching to a browser and HTML is another option, with the caveat that the curves and glyphs being manipulated are virtual entities existing only inside the fantasy world of the browser.</p><p>That aside, it is worth taking a moment to think about the expectations which have been built up over the decades about how static and inflexible most computing environments are.</p><p>Code is compiled and linked and sealed in self-contained executables. There's no concept of live-editing, of changing a running system, or at least that's relegated to certain interpreted languages or the distant memories of Smalltalk developers. Reaching for an open source JPEG library is often easier than using the native operating system--even though the OS is clearly capable of loading and displaying JPEGs--especially if you're not using the language it was designed to interface with.</p><p>We've gotten used to all of this, but there's no fundamental law dictating systems must be designed this way.</p><p>(If you liked this, you might enjoy <a href="159.html">The UNIX Philosophy and a Fear of Pixels</a>.)</p><p class="s"><a href="182.html" id="perm">permalink</a> <i>October 8, 2013</i></p><h1>previously</h1><ul><li><a href=181.html>Why Do Dedicated Game Consoles Exist?</a><li><a href=180.html>Purely Functional Photoshop</a><li><a href=179.html>How much memory does malloc(0) allocate?</a><li><a href=178.html>Getting Past the Cloning Instinct</a><li><a href=177.html>Organizational Skills Beat Algorithmic Wizardry</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>