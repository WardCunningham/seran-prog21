<!DOCTYPE html><html lang="en"><head><title>Remembering a Revolution That Never Happened</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Remembering a Revolution That Never Happened</h1><p>Twenty-three years ago, a book by Edward Cohen called <a href="http://www.amazon.com/Programming-1990s-Introduction-Calculation-Monographs/dp/0387973826">Programming in the 1990s: An Introduction to the Calculation of Programs</a> was published. It was a glimpse into the sparkling software development world of the future, a time when ad hoc coding would be supplanted by Dijkstra-inspired manipulation of proofs. Heck, no need to even run the resulting programs, because they're right by design.</p><p>Clearly Mr. Cohen's vision did not come to pass, but I co-opted the title for this blog.</p><p>That book is a difficult read. It starts out as bright-eyed and enthusiastic as you could expect a computer science text to be, then rapidly turns into chapter-long slogs to prove the equivalent of a simple linear search correct. It wasn't the difficulty that made the program derivation approach unworkable. Reading and writing music looks extraordinarily complex and clunky to the uninitiated, but that's not stopping vast numbers of people from doing so. The problem is that for almost any non-trivial program, it's not clear what "correct" means.</p><p>Here's a simple bit of code to write: display a sorted list of the filenames in a folder. That should take a couple of minutes, including googling around for how to get the contents of a directory.</p><p>Except that on some systems you're getting weird filenames like "." and ".." that you don't want to display.</p><p>Except that there are also hidden files, either based on an attribute or a naming convention, and you should ignore those too.</p><p>Except that you need the sort to be case insensitive or else the results won't make sense to most users.</p><p>Except that some people are using spaces between words and some are using underscores, so they should be treated the same when sorting.</p><p>Except that a naive sort is going to put "File 10" before "File 9", and while that's logical in the cold innards of the CPU, it's no excuse to present the data that way.</p><p>And this is a well-understood, weird old relic of a problem that's <i>nothing</i> compared to all the special cases and exceptions needed to implement a solid user experience in a modern app. Making beautiful code ugly--and maybe impossible to prove correct--by making things easier for the user is a good thing.</p><p>(If you liked this, you might enjoy <a href="87.html">Write Code Like You Just Learned How to Program</a>.)</p><p class="s"><a href="171.html" id="perm">permalink</a> <i>April 21, 2013</i></p><h1>previously</h1><ul><li><a href=170.html>Exploring the Lower Depths of Terseness</a><li><a href=169.html>Expertise, the Death of Fun, and What to Do About It</a><li><a href=168.html>Don't Be Distracted by Superior Technology</a><li><a href=167.html>Simplicity is Wonderful, But Not a Requirement</a><li><a href=166.html>The Highest-Level Feature of C</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>