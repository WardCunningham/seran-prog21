<!DOCTYPE html><html lang="en"><head><title>Revisiting "Programming as if Performance Mattered"</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Revisiting "Programming as if Performance Mattered"</h1><p>In 2004 I wrote <a href="http://www.dadgum.com/james/performance.html">Programming as if Performance Mattered</a>, which became one of my most widely read articles.  (If you haven't read it yet, go ahead; the rest of this entry won't make a lot of sense otherwise. Plus there are <b>spoilers</b>, something that doesn't affect most tech articles.) In addition to all the usual aggregator sites, it made <a href="http://www.slashdot.org">Slashdot</a> which resulted in a flood of email, both complimentary and bitter.  Most of those who disagreed with me can be divided into two groups.</p><p>The first group flat-out didn't get it.  They lectured me about how my results were an anomaly, that interpreted languages are dog slow, and that performance comes from hardcore devotion to low-level optimization.  This is even though my entire point was about avoiding knee-jerk definitions of <i>fast</i> and <i>slow</i>. The mention of game programming at the end was a particular sore point for these people.  "You obviously know nothing about writing games," they raved, "or else you'd know that every line of every game is carefully crafted for the utmost performance."  The amusing part is that I've spent almost my entire professional career--and a fairly unprofessional freelance stint before that--writing games.</p><p>The second group was more savvy. These people had experience writing image decoders and knew that my timings, from an absolute point of view, were nowhere near the theoretical limit.  I talked of decoding the sample image in under 1/60th of a second, and they claimed significantly better numbers.  And they're completely correct.  In most cases 1/60th of a second is plenty fast for decoding an image.  But if a web page has 30 images on it, we're now up to half a second just for the raw decoding time.  Good C code to do the same thing will win by a large margin.  So the members of this group, like the first, dismissed my overall point.</p><p>What surprised me about the second group was the assumption that my Erlang code is as fast as it could possibly get, when in fact there are easy ways of speeding it up.</p><p>First, just to keep the shock value high, I kept my code in pure, interpreted Erlang.  But there's a true compiler as part of the standard Erlang distribution, and simply compiling the <code>tga</code> module will halve execution time, if not decrease it by a larger factor.</p><p>Second, I completely ignored concurrent solutions, both within the decoding of a single image and potentially spinning each image into its own process.  The latter solution wouldn't improve execution time of my test case, but could be a big win if many images are decoded.</p><p>Then there's perhaps the most obvious thing to do, the first step when it comes to understanding the performance of real code.  Perhaps my detailed optimization account made it appear that I had reached the end of the road, that no more performance could be eked out of the Erlang code.  In any case, no one suggested <b>profiling</b> the code to see if there are any obvious bottlenecks. And there is such a bottleneck.</p><p>(There's one more issue too: in the end, the image decoder was sped-up enough that it was executing below the precision threshold of the wall clock timings of <code>timer:tc/3</code>.  I could go in and remove parts of the decoder--obviously giving incorrect results--and still get back the same timings of 15,000 microseconds.  The key point is that my reported timings were likely <i>higher</i> than they really were.)</p><p>Here's the output of the eprof profiler on <code>tga:test_compressed()</code>:</p><pre>FUNCTION                                       CALLS      TIME 

****** Process &lt;0.46.0&gt;    -- 100 % of profiled time *** 
tga:decode_rgb1/1                              54329      78 % 
lists:duplicate/3                              11790      7 % 
tga:reduce_rle_row/3                           2878       3 % 
tga:split/1                                    2878       3 % 
tga:combine/1                                  2874       3 % 
erlang:list_to_binary/1                        1051       2 % 
tga:expand/3                                   1995       1 % 
tga:continue_rle_row/7                         2709       1 % 
lists:reverse/1                                638        0 
...</pre><p>Sure enough, most of the execution time is spent in <code>decode_rgb1</code>, which is part of <code>decode_rgb</code>.  The final version of this function last time around was this:</p><pre>decode_rgb(Pixels) -&gt;
   list_to_binary(decode_rgb1(binary_to_list(Pixels))).
decode_rgb1([255,0,255 | Rest]) -&gt;
   [0,0,0,0 | decode_rgb1(Rest)];
decode_rgb1([R,G,B | Rest]) -&gt;
   [R,G,B,255 | decode_rgb1(Rest)];
decode_rgb1([]) -&gt; [].</pre><p>This is short, but contrived.  The binary blob of pixels is turned into a list, then the new pixels are built-up in reverse order as a list, and finally that list is reversed and turned back into a binary.  There are two reasons for the contrivance.  At the time, pattern matching was much faster on lists than binaries, so it was quicker to turn the pixels into a list up front (I timed it). Also, repeatedly appending to a binary was a huge no-no, so it was better to create a new list and turn it into a binary at the end.</p><p>In Erlang R12B both of these issues have been addressed, so <code>decode_rgb</code> can be written in the straightforward way, operating on binaries the whole time:</p><pre>decode_rgb(Pixels) -&gt; decode_rgb(Pixels, &lt;&lt;&gt;&gt;).
decode_rgb(&lt;&lt;255,0,255, Rest/binary&gt;&gt;, Result) -&gt;
   decode_rgb(Rest, &lt;&lt;Result/binary,0,0,0,0&gt;&gt;);
decode_rgb(&lt;&lt;R,G,B, Rest/binary&gt;&gt;, Result) -&gt;
   decode_rgb(Rest, &lt;&lt;Result/binary,R,G,B,255&gt;&gt;);
decode_rgb(&lt;&lt;&gt;&gt;, Result) -&gt; Result.</pre><p>This eliminates the memory pressure caused by expanding each byte of the binary to eight bytes (the cost of an element in a list).</p><p>But we can do better with a small change to the specification.  Remember, <code>decode_rgb</code> is a translation from 24-bit to 32-bit pixels.  When the initial pixel is a magic number--255,0,255--the alpha channel of the output is set to zero, indicating transparency.  All other pixels have the alpha set to 255, which is fully opaque. If you look at the code, you'll see that the 255,0,255 pixels actually get turned into 0,0,0,0 instead of 255,0,255,0.  There's no real reason for that. In fact, if we go with the simpler approach of only changing the alpha value, then <code>decode_rgb</code> can be written using in an amazingly clean way:</p><pre>decode_rgb(Pixels) -&gt;
   [&lt;&lt;R,G,B,(alpha(R,G,B))&gt;&gt; || &lt;&lt;R,G,B&gt;&gt; &lt;= Pixels].

alpha(255, 0, 255) -&gt; 0;
alpha(_, _, _) -&gt; 255.</pre><p>This version uses <b>bitstring comprehensions</b>, a new feature added in Erlang R12B. It's hard to imagine writing this with any less code.</p><p>(Also see the <a href="12.html">follow-up</a>.)</p><p class="s"><a href="11.html" id="perm">permalink</a> <i>December 16, 2007</i></p><h1>previously</h1><ul><li><a href=10.html>Finally: Data Structure Constants in Erlang</a><li><a href=9.html>Two Stories of Simplicity</a><li><a href=8.html>Deriving Forth</a><li><a href=7.html>Trapped! Inside a Recursive Data Structure</a><li><a href=6.html>Sending Modern Languages Back to 1980s Game Programmers</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>