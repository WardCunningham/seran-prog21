<!DOCTYPE html><html lang="en"><head><title>Starting in the Middle</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Starting in the Middle</h1><p>When I start on a personal project, I'm bright-eyed and optimistic. I've got an idea in my head, and all I need to do is implement it. Wait, before I can begin working on the good stuff there are some foundational underpinnings that don't yet exist. I work on those for a while, then I get back to main task...until I again realize that there are other, lower-level libraries that I need to write first.</p><p>Now I'm worried, because I'm building all this stuff, but I'm no closer to seeing results. I charge ahead and write one-off routines and do whatever it takes to get a working version one-point-oh. Then I hear the creaks and groans of impending code collapse. I shift my focus to architecture and move things to separate modules, refactor, sweep out dark corners, and eventually I'm back to thinking about the real problem. It's only a short respite. As the code gets larger and more complex, I find myself having to wear my software engineering hat more and more of the time, and that's no fun.</p><p>That's the story sometimes, anyway. When using functional programming languages I take a different approach: I pick an interesting little bit that's right in the middle of the problem and start working on it. I don't build up a foundation needed to support the solution. I don't think about how it integrates into the whole. There's a huge win here that should be the selling point of functional programming: you can build large programs without worrying about architecture.</p><p>Okay, sure, that architecture dodge isn't <i>entirely</i> true, but it's dramatic enough that I'm surprised functional programming isn't the obvious choice for anyone writing "So you want to learn to program?" tutorials. Or at least that it isn't the focus of "Why Functional Programming is Great" essays. If nothing else, it's a more compelling hook than currying or type systems.</p><p>How can starting a project in the middle possibly work? By writing symbolic code that lets me put off as many design decisions as possible. If I'm writing the "move entity" function for a <a href="23.html">video game</a>, the standard approach is to directly modify a structure or object representing that entity. It's much easier to return a description of the change, like <code>{new_ypos, 76}</code> or <code>{new_color, red}</code>. (Those are both Erlang tuples.) That avoids the whole issue of how to rebuild what may be a complex, nested data structure with a couple of new values.</p><p>If I want to multiply the matrices M and N, the result is <code>{'*', M, N}</code>. (This is another Erlang tuple. The single quotes around the asterisk mean that it's an atom--a symbol in Lisp or Scheme. Those quotes are only necessary if the atom isn't alphanumeric.) The function to transpose a matrix returns <code>{transpose, M}</code>.</p><p>It looks like the essential work is being dodged, but it depends what you're after. I can write code and see at a glance that it gives the right result. I can use those functions to create more interesting situations and learn about the problem. If I find my understanding of the problem is wrong, and I need to back up, that's okay. It's more than okay: it's great! Maybe it turns out that I don't need to multiply matrices after all, so I didn't waste time writing a multiply routine. Maybe the transpose function is always called with a parameter of <code>{transpose, Something}</code>, so the two transpositions cancel out and there's no need to do anything.</p><p>At some point I have to stop living this fantasy and do something useful with these abstract descriptions. Hopefully by that time my experiments in symbolic programming have better defined both the problem and the solution, and I won't need to spend as much time thinking about boring things like architecture.</p><p>(If you liked this, you might enjoy <a href="66.html">Living Inside Your Own Black Box</a>.)</p><p class="s"><a href="115.html" id="perm">permalink</a> <i>October 24, 2011</i></p><h1>previously</h1><ul><li><a href=114.html>Papers from the Lost Culture of Array Languages</a><li><a href=113.html>The Revolution is Personal</a><li><a href=112.html>Optimization on a Galactic Scale</a><li><a href=111.html>Greetings from the Bottom of the Benchmarks</a><li><a href=110.html>Beyond Empty Coding</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>