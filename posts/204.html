<!DOCTYPE html><html lang="en"><head><title>Life is More Than a Series of Cache Misses</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Life is More Than a Series of Cache Misses</h1><p>I don't know what to make of the continual stream of people in 2015 with fixations on low-level performance and control. I mean the people who deride the cache-obliviousness of linked lists, write-off languages that aren't near the top of the benchmark table, and who rant about the hopelessness of garbage collection. They're right in some ways. And they're wrong at the same time.</p><p>Yes, you can do a detailed analysis of linked list traversal and realize "Hey! Looping over an array is much faster!" It is not news to anyone that different languages have different performance characteristics. Garbage collection is a little trickier, because unfortunately <a href="134.html">there are still issues</a> depending on the situation, and not all that rarely either.</p><p>I could take a little Erlang or Scheme program and put on a show, publicly tearing it to pieces, analyzing the inefficiencies from dynamic typing and immutability and virtual machines. There would be foot stomping and cheering and everyone would leave convinced that we've been fooling ourselves and that the only way to write code is to frame problems in terms of cache architectures.</p><p>And then I'd reveal that the massively inefficient Erlang program takes only a couple of milliseconds to run.</p><p>Back in the 1990s I decided to modernize my skills, because my experience was heavily skewed toward low-level C and assembly work. I went through tutorials for a number of modern languages before settling on Erlang. While learning, I wrote programs for problems I did in college. Things like tree manipulation, binary search--the classics. And while I remember these being messy in C and Pascal, writing them in Erlang was <i>fun</i>. I'm not giving up that fun if I can help it. Fun is more productive. Fun leads to a better understanding of the problem domain. And that leads to fast code, even if it might be orders of magnitude away from optimal when viewed through a microscope.</p><p>There is an exception to all of this. Imagine you're an expert in building a very specific type of application. You've shipped five of them so you've got a map of all the sinkholes and poorly lit places. There's a chance, maybe, depending on your background, that your knowledge transcends the capabilities provided by higher level programming languages, and you can easily crystallize a simple, static architecture in C.</p><p>But until I'm that expert, I'll take the fun.</p><p class="s"><a href="204.html" id="perm">permalink</a> <i>February 24, 2015</i></p><h1>previously</h1><ul><li><a href=203.html>Retiring Python as a Teaching Language</a><li><a href=202.html>The Software Developer's Sketchbook</a><li><a href=201.html>Programming Modern Systems Like It Was 1984</a><li><a href=200.html>Extreme Formatting</a><li><a href=199.html>Design is Expensive</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>