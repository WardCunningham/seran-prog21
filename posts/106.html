<!DOCTYPE html><html lang="en"><head><title>"Avoid Premature Optimization" Does Not Mean "Write Dumb Code"</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>"Avoid Premature Optimization" Does Not Mean "Write Dumb Code"</h1><p>First there's a flurry of blog entries citing a snippet of a Knuth quote: "premature optimization is the root of all evil." Then there's the backlash about how performance needs to be considered up front, that optimization isn't something that can be patched in at the end. Around and around it goes.</p><p>What's often missed in these discussions is that the advice to "avoid premature optimization" is not the same thing as "write dumb code." You should still try to make programs clear and reliable and factor out common operations and use good names and all the usual stuff. There's this peculiar notion that as soon as you ease up on the hardcore optimization pedal, then you go all mad and regress into a primitive mindset that thinks BASIC on an Apple ][ is the epitome of style and grace.</p><p>The warning sign is when you start sacrificing clarity and reliability while chasing some vague notion of performance.</p><p>Imagine you're writing an application where you frequently need to specify colors. There's a nice list of <a href="http://www.w3schools.com/html/html_colornames.asp">standard HTML color names</a> which is a good starting point. A color can be represented as an Erlang atom: tomato, lavenderBlush, blanchedAlmond. Looking up the R,G,B value of a color, given the name, is straightforward:</p><pre>color(tomato) -&gt; {255,99,71};
color(lavenderBlush) -&gt; {255,240,245};
color(blanchedAlmond) -&gt; {255,235,205};
...</pre><p>That's beautiful in its textual simplicity, but what's going on behind the scenes? That function gets turned into the virtual machine equivalent of a <code>switch</code> statement. At load time, some additional optimization gets done and that <code>switch</code> statement is transformed into a binary search for the proper atom.</p><p>What if, instead of atoms, colors are represented by integers from zero to some maximum value? That's easy with macros:</p><pre>-define(Tomato, 0).
-define(LavenderBlush 1).
-define(BlanchedAlmond, 2).
...</pre><p>This change allows the <code>color</code> function to be further, automatically, optimized at load time. The keys are consecutive integers, so there's no need for a search. At runtime there's a bounds check and a look-up, and that's it. It's hands-down faster than the binary search for an atom.</p><p>What's the price for this undefined amount of extra speed? For starters, colors get displayed as bare integers instead of symbolic names. An additional function to convert from an integer to a name string fixes that...well, except in post-crash stack traces. The easy-to-read and remember names can't be entered interactively, because macros don't exist in the shell. And the file containing the macros has to be included in every source file where colors are referenced, adding dependencies to the project that otherwise wouldn't be present.</p><p>The verdict? This is madness: sacrificing ease of development, going against the grain of Erlang, all in the name of nanoseconds.</p><p>(If you liked this, you might enjoy <a href="9.html">Two Stories of Simplicity</a>.)</p><p class="s"><a href="106.html" id="perm">permalink</a> <i>August 17, 2011</i></p><h1>previously</h1><ul><li><a href=105.html>Collapsing Communities</a><li><a href=104.html>8-Bit Scheme: A Revisionist History</a><li><a href=103.html>The End is Near for Vertical Tab</a><li><a href=102.html>The Nostalgia Trap</a><li><a href=101.html>Living in the Era of Infinite Computing Power</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>