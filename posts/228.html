<!DOCTYPE html><html lang="en"><head><title>Writing Video Games in a Functional Style</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Writing Video Games in a Functional Style</h1><p>When I started this blog in 2007, a running theme was "Can interactive experiences like video games be written in a functional style?" These are programs heavily based around mutable state. They evolve, often drastically, during development, so there isn't a perfect up-front design to architect around. These were issues curiously avoided by the functional programming proponents of the 1980s and 1990s.</p><p>It's still not given much attention in 2016 in either. I regularly see excited tutorials about mapping and folding and closures and immutable variables, and even JavaScript has these things now, but there's a next step that's rarely discussed and much more difficult: how to keep the benefits of immutability in large and messy programs that could gain the most from functional solutions--like video games.</p><p>Before getting to that, here are the more skeptical functional programming articles I wrote, so it doesn't look like I'm a raving advocate:</p><ul>
<li><a href="3.html">Admitting that Functional Programming Can Be Awkward</a></li>
<li><a href="18.html">Back to the Basics of Functional Programming</a></li>
<li><a href="31.html">Functional Programming Went Mainstream Years Ago</a></li>
<li><a href="38.html">Puzzle Languages</a></li>
<li><a href="41.html">Let's Take a Trivial Problem and Make it Hard</a></li>
<li><a href="54.html">Functional Programming Doesn't Work (and what to do about it)</a></li>
</ul><p>I took a straightforward, arguably naive, approach to interactive functional programs: no monads (because I didn't understand them), no functional-reactive programming (ditto, plus all implementations had severe performance problems), and instead worked with the basic toolkit of function calls and immutable data structures. It's completely possible to write a video game (mostly) in that style, but it's not a commonly taught methodology. "Purely Functional Retrogames" has most of the key lessons, but I added some additional techniques later:</p><ul>
<li><a href="23.html">Purely Functional Retrogames</a> (4 parts)</li>
<li><a href="131.html">Turning Your Code Inside Out</a></li>
<li><a href="189.html">A Worst Case for Functional Programming?</a></li>
<li><a href="216.html">Messy Structs/Classes in a Functional Style</a></li>
<li><a href="207.html">Reconsidering Functional Programming</a></li>
</ul><p>The bulk of my experience came from rewriting a 60fps 2D shooter in mostly-pure Erlang. I wrote about it in <a href="157.html">An Outrageous Port</a>, but there's not much detail. It really needed to be a multi-part series with actual code.</p><p>For completeness, here are the other articles that directly discuss FP:</p><ul>
<li><a href="14.html">Functional Programming Archaeology</a></li>
<li><a href="36.html">Accidentally Introducing Side Effects into Purely Functional Code</a></li>
<li><a href="73.html">Explaining Functional Programming to Eight-Year-Olds</a></li>
<li><a href="79.html">Erlang vs. Unintentionally Purely Functional Python</a></li>
<li><a href="115.html">Starting in the Middle</a></li>
<li><a href="138.html">You, Too, Can Be on the Cutting Edge of Functional Programming Research</a></li>
<li><a href="176.html">Tips for Writing Functional Programming Tutorials</a></li>
<li><a href="180.html">Purely Functional Photoshop</a></li>
</ul><p>If I find any I missed, I'll add them.</p><p class="s"><a href="228.html" id="perm">permalink</a> <i>December 29, 2016</i></p><h1>previously</h1><ul><li><a href=227.html>Progress Bars are Surprisingly Difficult</a><li><a href=226.html>Learning to Program Without Writing the Usual Sort of Code</a><li><a href=225.html>Picturing WebSocket Protocol Packets</a><li><a href=224.html>Being More Than "Just the Programmer"</a><li><a href=223.html>The New Minimalism</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>