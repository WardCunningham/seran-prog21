<!DOCTYPE html><html lang="en"><head><title>Sending Modern Languages Back to 1980s Game Programmers</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Sending Modern Languages Back to 1980s Game Programmers</h1><p>Take a moment away from the world of Ruby, Python, and JavaScript to consider some of the more audacious archaeological relics of computing: the tens of thousands of commercial products written entirely in assembly language.</p><p>That's every game ever written for the Atari 2600.  Almost all Apple II games and applications, save early cruft written in BASIC (which was itself written in assembly).  VisiCalc.  Almost all Atari 800 and Commodore 64 and Sinclair Spectrum games and applications.  Every NES cartridge.  Almost every arcade coin-op from the 1970s until the early 1990s, including elaborate 16-bit affairs like Smash TV, Total Carnage, and NBA Jam (in case you were only thinking of "tiny sprite on black background" games like Pac-Man).  Almost all games for the SNES and SEGA Genesis.  And I'm completely ignoring an entire mainframe era that came earlier.</p><p>(It's also interesting to look at 8-bit era software that <i>wasn't</i> written in assembly language.  A large portion of <a href="http://en.wikipedia.org/wiki/SunDog:_Frozen_Legacy">SunDog: Frozen Legacy</a> for the Apple II was written in interpreted Pascal.  The <a href="http://en.wikipedia.org/wiki/Homepak">HomePak</a> integrated suite of applications for the Atari 8-bit computers was written in a slick language called <a href="http://en.wikipedia.org/wiki/Action!">Action!</a>.  The 1984 coin-op <a href="http://en.wikipedia.org/wiki/Marble_Madness">Marble Madness</a> was one of the few games of the time written in C, and that allowed it to easily be ported to the Amiga and later the Genesis. A handful of other arcade games used Bliss.)</p><p>Back in 1994, I worked on a SNES game that was 100,000+ lines of 65816 assembly language.  Oh yeah, no debugger either.  It sounds extreme, almost unthinkable, but there weren't good options at the time.  You use what you have to.  So many guitar players do what looks completely impossible to me, but there's no shortage of people willing to take the time to play like that.  Assembly language is pretty straightforward, provided you practice a lot and don't waste time dwelling on its supposed difficulty.</p><p>If you want <i>really</i> extreme there were people <i>hand assembling</i> Commodore 64 code and even people writing Apple II games <i>entirely in the machine language monitor</i> (a friend who clued me into this said you can look at the disassembled code and see how functions are aligned to 256 byte pages, so they can be modified without having to shift around the rest of the program).</p><p>It's an interesting exercise to consider what it would have been like to write games for these old, limited systems, but given modern hardware and a knowledge of modern tools: Perl, Erlang, Python, etc.  No way would I have tried to write a Commodore 64 game in Haskell or Ruby, but having the languages <i>available</i> and on more powerful hardware would have changed everything.  Here's what I'd do.</p><p><b>Write my own assembler.</b> This sounded so difficult back then, but that's because parsing and symbol table management were big efforts in 6502 code.  Getting it fast would have taken extra time, too.  But now writing a cross assembler in Erlang (or even Perl) is a weekend project at best.  A couple hundred lines of code.</p><p><b>Write my own emulator.</b> I don't mean a true, performance-oriented emulator for running old code on a modern PC.  I mean a simple interpreter for stepping through code and making sure it works without having real crashes on the target hardware.  Again, this would be a quick project.  It's what functional languages are designed to do.  More than just executing code, I'd want to make queries about which registers a routine changes, get a list of all memory addresses read or modified by a function, count up the cycles in any stretch of code.  This is all trivially easy, but it was so out of my realm as a self-taught game author.  (And for development tool authors of the time, too.  I never saw features like these.)</p><p><b>Write my own optimizers for tricky cases.</b>  The whole point of assembly is to have control, but some optimizations are too ugly to do by hand.  A good example is realizing that the carry flag is always set when a jump instruction occurs, so the jump (3 bytes) can be replaced with a conditional branch (2 bytes).</p><p><b>Write my own custom language.</b>  I used to worship at the altar of low-level optimization, but all of that optimization was more or less pattern recognition or brute force shuffling of code to minimize instructions.  I still, even today, cringe at the output I see from most compilers (I have learned that it's best not to look), because generating perfect machine code from a complex language is a tough problem.  But given a simple processor like the 6502, 6089, or Z80, I think it would not only be possible to automate all of my old tricks, but to go beyond them into the realm of "too scary to mess with" optimizations.  Self-modifying code is a good example.  For some types of loops you can't beat stuffing constants into the compare instructions.  Doing this by hand...ugh.</p><p>Much of the doability of these options comes from the simplicity of 8-bit systems.  Have you ever looked into the details of the COFF or Preferred Executable format?  Compare the pages and pages of arcana to the six byte header of an Atari executable.  Or look at the 6502 instruction set summarized on a single sheet of paper, compared with the two volume set of manuals from Intel for the x86 instructions.  But a big part of it also comes from modern programming languages and how 
pleasant they make approaching problems that would have previously been full-on projects.</p><p class="s"><a href="6.html" id="perm">permalink</a> <i>November 20, 2007</i></p><h1>previously</h1><ul><li><a href=5.html>Erlang as a Target for Imperative DSLs</a><li><a href=4.html>Follow-up to "Admitting that Functional Programming Can Be Awkward"</a><li><a href=3.html>Admitting that Functional Programming Can Be Awkward</a><li><a href=2.html>On the Perils of Benchmarking Erlang</a><li><a href=1.html>A Deeper Look at Tail Recursion in Erlang</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>