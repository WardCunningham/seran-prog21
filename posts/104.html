<!DOCTYPE html><html lang="en"><head><title>8-Bit Scheme: A Revisionist History</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>8-Bit Scheme: A Revisionist History</h1><p>In <a href="102.html">The Nostalgia Trap</a> I wrote, "I was in contact with a hundred or more designers of 8-bit computer games, and I learned their stories." Those stories were fantastically interesting, but most of them were only incidentally about programming. The programming side usually went like this:</p><p>Early home computers were <a href="59.html">magic</a>, and upon seeing one there was a strong desire to learn how to control it and create experiences from moving graphics and sound. At power-up there was the prompt from a BASIC interpreter, and there was a BASIC reference manual in the box, so that was the place to start.</p><p>Later there was serendipitous exposure to some fast and impressive game that was far beyond the animated character graphics or slow line-drawing of BASIC, and that led to the discovery of assembly language and the freedom to exploit the hardware that came with it. It was suitably clunky to be writing a seven instruction sequence to do 16-bit addition and remembering that "branch on carry set" could be thought of as "branch on unsigned greater or equal to." The people with prior programming experience, the ones who already knew C or Algol or Scheme, they may have been dismayed at the primitive nature of it all, but really it came down to "you do what you have to do." The goal was never to describe algorithms in a concise and expressive manner, but to get something interactive and wonderful up on the screen.</p><p>Now imagine if an Atari 800 or Commodore 64 shipped with a CPU designed to natively run a high-level language like Scheme. That's not completely outrageous; Scheme chips were being developed at MIT in the late 1970s.</p><p>My suspicion is that Scheme would have been learned by budding game designers without a second thought. Which language it was didn't matter nearly so much as having <b>a</b> language that was clearly the right choice for the system. All the quirks and techniques of Scheme would have been absorbed and worked around as necessary.</p><p>It's not so simple with today's abundance of options, none of which is perfect. Haskell is beautiful, but it looks difficult to reason about the memory usage of Haskell code. Erlang has unappealing syntax. Python is inconsistently object-oriented. Lisp is too bulky--Scheme too minimalist. All of these ring more of superficiality than the voice of experience. Yet those criticisms are preventing the deep dive needed to get in there and find out how a language holds up for a real project.</p><p>What if you <i>had</i> to use Scheme? Or Haskell? Or Erlang? You might slog it out and gain a new appreciation for the mundane, predictable nature of C. Or you might find out that once you've worked through a handful of tricky bits, there are great advantages in working with a language that's more pleasant and reliable. Either way, you will have learned something.</p><p>(If you liked this, you might enjoy <a href="19.html">Five Memorable Books About Programming</a>.)</p><p class="s"><a href="104.html" id="perm">permalink</a> <i>August 4, 2011</i></p><h1>previously</h1><ul><li><a href=103.html>The End is Near for Vertical Tab</a><li><a href=102.html>The Nostalgia Trap</a><li><a href=101.html>Living in the Era of Infinite Computing Power</a><li><a href=100.html>Tough Love for Indies</a><li><a href=99.html>Constantly Create</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>