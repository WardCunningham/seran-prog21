<!DOCTYPE html><html lang="en"><head><title>Timidity Does Not Convince</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Timidity Does Not Convince</h1><p>The only arguments that hold water, in terms of programming language suitability, are bold, finished projects. Not a mini-Emacs written in Haskell. Not a Sudoku solver in Prolog. Not a rewrite of some 1970s video game using Functional Reactive Programming. They need to be large and daring projects, where the finished product is impressive in its own right, and then when you discover it was written in language X, there's a wave of disbelief and then a new reverence for a toolset you had previously dismissed.</p><p>And now, two of my favorite bold projects:</p><h2>Wings 3D</h2><p>Wings started as an attempt to clone Nendo, a 3D modeller designed around simplicity and ease of use. Nendo development and support had dried-up, and enthusiasm for Nendo fueled Wings 3D development. So now there's a full-featured, mature 3D modeller, with a great focus on usability, and it's written entirely in Erlang. Without a doubt it's the antithesis of what Erlang was designed for, with the entire program running as a single process and intensive use of floating point math. But it clearly works, and shows that there are benefits to using Erlang even outside of its niche of concurrency-oriented programming.</p><h2>SunDog: Frozen Legacy</h2><p>SunDog was an elaborate game for the Apple II. A 1MHz 6502 and 48K of memory look more like a platform for simple arcade games, not the space trading and exploration extravaganza that was SunDog. And though assembly language was the norm for circa-1984 commercial games, the authors--Bruce Webster and Wayne Holder--chose to implement the majority of the game in p-code interpreted Pascal. I found a justification in an old email from Bruce:</p><blockquote><p>Wayne and I had some long discussions about what to use to write SunDog (which
actually started out being another game). We considered assembly, FORTH, and
Pascal; BASIC was far too slow and clumsy for what we wanted to do. We ended up
ruling out FORTH for issues of maintenance (ours and lack of a commercial
vendor).</p><p>I pushed for--and we decided on--Apple Pascal for a few different
reasons, including the language itself; the compactness of the p-code; and the
automatic (but configurable) memory management of the p-System, which could
swap "units" (read: modules) in and out. Pascal made the large project easier,
not harder, though it was a struggle to keep the game within 48KB.</p></blockquote><p>And that's how it should be: choose the language that lets you implement your vision.</p><p class="s"><a href="35.html" id="perm">permalink</a> <i>November 30, 2008</i></p><h1>previously</h1><ul><li><a href=34.html>Macho Programming</a><li><a href=33.html>Understanding What It's Like to Program in Forth</a><li><a href=32.html>Kilobyte Constants, a Simple and Beautiful Idea that Hasn't Caught On</a><li><a href=31.html>Functional Programming Went Mainstream Years Ago</a><li><a href=30.html>Want to Write a Compiler? Just Read These Two Papers.</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>