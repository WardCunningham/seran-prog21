<!DOCTYPE html><html lang="en"><head><title>Understanding What It's Like to Program in Forth</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Understanding What It's Like to Program in Forth</h1><p><i>I write Forth code every day. It is a joy to write a few simple words and solve a problem. As brain exercise it far surpasses cards, crosswords or Sudoku</i></p><p style="text-align:right">&mdash;<a href="https://web.archive.org/web/20080828053757/http://www.computerworld.com.au/index.php/id;766897508;fp;16;fpid;1">Chuck Moore</a>, creator of Forth</p><p>I've used and enjoyed Forth quite a bit over the years, though I rarely find myself programming in it these days. Among other projects, I've written several standalone tools in Forth, used it for exploratory programming, wrote a Forth-like language for handling data assets for a commercial project, and wrote two standalone 6502 cross assemblers using the same principles as Forth assemblers.</p><p>It's easy to show how beautiful Forth can be.  The classic example is:</p><pre>: square dup * ;</pre><p>There's also Leo Brodie's oft-cited <a href="http://home.iae.nl/users/mhx/sf1/sf1.html">washing machine</a> program.  But as pretty as these code snippets are, they're the easy, meaningless examples, much like the <a href="http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell">two-line quicksort in Haskell</a>.  They're trotted out to show the the strengths of a language, then reiterated by new converts.  The primary reason I wrote the <a href="http://prog21.dadgum.com/23.html">Purely Functional Retrogames</a> series, is because of the disconnect between advocates saying everything is easy without destructive updates, and the utter lack of examples of how to approach many kinds of problems in a purely functional way.  The same small set of pretty examples isn't enough to understand what it's like to program in a particular language or style.</p><p>Chuck Moore's Sudoku quote above is one of the most accurate characterizations of Forth that I've seen.  Once you truly understand it, you'll better see what's fun about the language, and also why it isn't as commonly used.  What I'd like to do is to start with a trivially simple problem, one that's completely straightforward, even simpler than the infamous <a href="http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/">FizzBuzz</a>:</p><blockquote><p>Write a Forth word to add together two integer vectors (a.k.a. arrays) of three elements each.</p></blockquote><p>The C version, without bothering to invent custom data types, requires no thought:</p><pre>void vadd(int *v1, int *v2, int *v3)
{
       v3[0] = v1[0] + v2[0];
       v3[1] = v1[1] + v2[1];
       v3[2] = v1[2] + v2[2];
}</pre><p>In Erlang it's:</p><pre>vadd({A,B,C}, {D,E,F}) -&gt; {A+D, B+E, C+F}.</pre><p>In APL and J the solution is a single character:</p><pre>+</pre><h2>first Forth attempt</h2><p>So now, Forth.  We start with a name and stack picture:</p><pre>: vadd ( v1 v2 v3 -- )</pre><p>Getting the first value out of v1 is easy enough:</p><pre>rot dup @</pre><p>"<code>rot</code>" brings v1 to the top, then we grab the first element of the array (remember that we need to keep v1 around, hence the <code>dup</code>).  Hmmm...now we've got four items on the stack:</p><pre>v2 v3 v1 a</pre><p>"a" is what I'm calling the first element of v1, using the same letters as in the Erlang function.  There's no way to get v2 to the top of the stack, save the deprecated word <code>pick</code>, so we're stuck.</p><h2>second Forth attempt</h2><p>Thinking about this a bit more, the problem is we have too many items being dealt with at once, too many items on the stack.  v3 sitting there on top is getting in the way, so what if we moved it somewhere else for a while?  The return stack is the standard location for a temporary value, so let's try it:</p><pre>&gt;r over @ over @ + r&gt; !</pre><p>Now that works.  We get v3 out of the way, fetch v1 and v2 (keeping them around for later use), then bring back v3 and store the result.  Well, almost, because now v3 is gone and we can't use it for the second and third elements.</p><h2>third Forth attempt</h2><p>This isn't as bad as it sounds.  We can just keep v3 over on the return stack for the whole function.  Here's an attempt at the full version of <code>vadd</code>:</p><pre>: vadd ( v1 v2 v2 -- )
       &gt;r
       over @ over @ + r@ !
       over cell+ @ over cell+ @ + r@ cell+ !
       over 2 cells + @ over 2 cells + @ + r&gt; 2 cells + !
       drop drop ;</pre><p><code>cell+</code> is roughly the same as <code>++</code> in C.  "<code>2 cells +</code>" is equivalent to "<code>cell+ cell+</code>".  Notice how v3 stays on the return stack for most of the function, being fetched with <code>r@</code>.  The "<code>drop drop</code>" at the end is to get rid of v1 and v2.  Some nicer formatting helps show the symmetry of this word:</p><pre>: vadd ( v1 v2 v2 -- )
       &gt;r
       over           @  over           @  + r@           !
       over cell+     @  over cell+     @  + r@ cell+     !
       over 2 cells + @  over 2 cells + @  + r&gt; 2 cells + !
       drop drop ;</pre><p>This can be made more obvious by defining some vector access words:</p><pre>: 1st ;
: 2nd cell+ ;
: 3rd 2 cells + ;
: vadd ( v1 v2 v2 -- )
       &gt;r
       over 1st @  over 1st @  + r@ 1st !
       over 2nd @  over 2nd @  + r@ 2nd !
       over 3rd @  over 3rd @  + r&gt; 3rd !
       drop drop ;</pre><p>A little bit of extra verbosity removes one quirk in the pattern:</p><pre>: vadd ( v1 v2 v2 -- )
       &gt;r
          over 1st @  over 1st @  + r@ 1st !
          over 2nd @  over 2nd @  + r@ 2nd !
          over 3rd @  over 3rd @  + r@ 3rd !
       rdrop drop drop ;</pre><p>And that's it--three element vector addition in Forth. One solution at least; I can think of several completely different approaches, and I don't claim that this is the most concise of them. It has some interesting properties, not the least of which is that there aren't any named variables. On the other hand, all of this puzzling, all this revision...to solve a problem which takes no thought at all in most languages. And while the C version can be switched from integers to floating point values just by changing the parameter types, that change would require <i>completely rewriting the Forth code</i>, because there's a separate floating point stack.</p><p>Still, it was enjoyable to work this out. Better than Sudoku?  Yes.</p><p class="s"><a href="33.html" id="perm">permalink</a> <i>August 2, 2008</i></p><h1>previously</h1><ul><li><a href=32.html>Kilobyte Constants, a Simple and Beautiful Idea that Hasn't Caught On</a><li><a href=31.html>Functional Programming Went Mainstream Years Ago</a><li><a href=30.html>Want to Write a Compiler? Just Read These Two Papers.</a><li><a href=29.html>A Spellchecker Used to Be a Major Feat of Software Engineering</a><li><a href=28.html>Coding as Performance</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>