<!DOCTYPE html><html lang="en"><head><title>How Much Processing Power Does it Take to be Fast?</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>How Much Processing Power Does it Take to be Fast?</h1><p>First, watch <a href="http://www.youtube.com/watch?v=IIGrqUJoBns">this</a>.</p><p>It's Defender, an arcade game released thirty years ago. I went out of my way to find footage running on the original hardware, not emulated on a modern computer. (There's <a href="https://www.youtube.com/watch?v=gss3lxeqCok">clearer video</a> from an emulator if you prefer.)</p><p>Here's the first point of note: Defender is running on a 1MHz 8-bit processor. That's right ONE megahertz. This was before the days of pipelined, superscalar architectures, so if an instruction took 5 cycles to execute, it always took 5 cycles.</p><p>Here's the second: Unlike a lot of games from the early 1980s, there's no hardware-assisted graphics. No honest-to-goodness sprites where the video processor does all the work. No hardware to move blocks of memory around. The screen is just a big bitmap, and all drawing of the enemies, the score, the scrolling mountains, the special effects, is handled by the same processor that's running the rest of the code.</p><p>To be fair, the screen is only 320x256 with four bits per pixel. But remember, this was 1980, and home computers released up until mid-1985 didn't have that combination of resolution and color.</p><p>Now it's 2010, and there's much amazement at the responsiveness of the <a href="59.html">iPad</a>. And why shouldn't it be responsive? There's a 32-bit, gigahertz CPU in there that can run multiple instructions at the same time. Images are moved around by a separate processor dedicated entirely to graphics. When you flick your finger across the screen and some images slide around, <i>there's very little computation involved</i>. The CPU is tracking some input and sending some commands to the GPU. The GPU is happy to render what you want, and a couple of 2D images is way below the tens of thousands of texture-mapped polygons that it was designed to handle.</p><p>Okay, JPEG decompression takes some effort. Ditto for drawing curve-based, anti-aliased fonts. And of course there's overhead involved in the application framework where messages get passed around to delegates and so on. None of this justifies the assumption that it takes amazing computing power to provide a responsive user experience. We're so used to interfaces being clunky and static, and programs taking long to load, and there being unsettling pauses when highlighting certain menu items, that we <em>expect</em> it.</p><p>All the fawning over the speed iPad is a good reminder that it doesn't have to be this way.</p><p>(If you liked this, you might like <a href="52.html">Slow Languages Battle Across Time</a>.)</p><p class="s"><a href="68.html" id="perm">permalink</a> <i>April 24, 2010</i></p><h1>previously</h1><ul><li><a href=67.html>Rethinking Programming Language Tutorials</a><li><a href=66.html>Living Inside Your Own Black Box</a><li><a href=65.html>A Short Story About Verbosity</a><li><a href=64.html>Eleven Years of Erlang</a><li><a href=63.html>It Made Sense in 1978</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>