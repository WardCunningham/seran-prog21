<!DOCTYPE html><html lang="en"><head><title>Functional Programming Archaeology</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Functional Programming Archaeology</h1><p><a href="http://en.wikipedia.org/wiki/John_Backus">John Backus</a>'s Turing Award Lecture from 1977, <a href="http://www.stanford.edu/class/cs242/readings/backus.pdf">Can Programming be Liberated from the Von Neumann Style?</a> (warning: large PDF) was a key event in the history of functional programming.  All of the ideas in the paper by no means originated with Backus, and Dijkstra publicly <a href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD692.html">criticized</a> it for being poorly thought through, but it did spur interest in functional programming research which eventually led to languages such as Haskell.  And the paper is historically interesting as the crystallization of the beliefs about the benefits of functional programming at the time.  There are two which jump out at me.</p><p>The first is concurrency as a primary motivation.  If a program is just a series of side effect-free expressions, then there's no requirement that programs be executed sequentially.  In a function call like this:</p><pre>f(ExpressionA, ExpressionB, ExpressionC)</pre><p>the three expressions have no interdependencies and can be executed in parallel. This could, in theory, apply all the way down to pieces of expressions.  In this snippet of code:</p><pre>(a + b) * (c + d)</pre><p>the two additions could be performed at the same time.  This fine-grained concurrency was seen as a key benefit of purely functional programming languages, but it fizzled, both because of the difficulty in determining how to parallelize programs efficiently and because it was a poor match for monolithic CPUs.</p><p>The second belief which has dropped off the radar since 1977 is the concept of an algebra of programs.  Take this simple C expression:</p><pre>!x</pre><p>Assuming <code>x</code> is a truth value--either 0 or 1--then <code>!x</code> gives the same result as these expressions:</p><pre>1 - x
x ^ 1
(x + 1) &amp; 1</pre><p>If the last of these appeared in code, then it could be mechanically translated to one of the simpler equivalents.  Going further, you could imagine an interactive tool that would allow substitution of equivalent expressions, maybe even pointing out expressions that can be simplified.</p><p>Now in C this isn't all that useful.  And in Erlang or Haskell it's not all that useful either, unless you avoid writing explicitly recursive functions with named values and instead express programs as a series of canned manipulations.  This is the so-called <a href="http://haskell.org/haskellwiki/Pointfree">point-free style</a> which has a reputation for density to the point of opaqueness.</p><p>In Haskell code, point-free style is common, but not aggressively so.  Rather than trying to work out a way to express a computation as the application of existing primitives, it's usually easier to write an explicitly recursive function. Haskell programmers aren't taught to lean on core primitive functions wherever possible, and core primitive functions weren't necessarily designed with that goal in mind.  Sure, there's the usual <code>map</code> and <code>fold</code> and so on, but not a set of functions that would allow 90% of all programs to be expressed as application of those primitives.</p><p><i>Can Programming be Liberated...</i> introduced <b>fp</b>, a language which didn't catch on and left very little in the way of tutorials or useful programming examples.  fp was clearly influenced by Ken Iverson's APL, a language initially defined n 1962 (and unlike fp, you can still hunt down production code written in APL).  The APL lineage continued after Backus's paper, eventually leading to APL2 and J (both of which involved Iverson) and a second branch of languages created by a friend of Iverson, Arthur Whitney: A+, K, and Q.  Viewed in the right light, J is a melding of APL and fp.  And the "build a program using core primitives" technique lives on in J.</p><p>Here's a simple problem: given an array (or list, if you prefer), return the indices of values which are greater than 5.  For example, this input:</p><pre>1 2 0 6 8 3 9 </pre><p>gives this result:</p><pre>3 4 6</pre><p>which means that the elements in the original array at positions 3, 4, and 6 (where the first position is zero, not one) are all greater than 5.  I'm using the APl/J/K list notation here, instead of the Haskelly <code>[3,4,6]</code>.  How can we transform the original array to <code>3 4 6</code> without explicit loops, recursion, or named values?</p><p>First, we can find out which elements in the input list are greater than 5.  This doesn't give us their positions, but it's a start.</p><pre>0 2 0 6 8 3 9 &gt; 5
0 0 0 1 1 0 1 </pre><p>The first line is the input, the second the output.  Greater than, like most J functions, operates on whole arrays, kind of like all operators in Haskell having <code>map</code> built in.  The above example checks if each element of the input array is greater than 5 and returns an array of the results (0 = false, 1 = true).</p><p>There's another J primitive that builds a list of values from 0 up to n-1:</p><pre>i. 5
0 1 2 3 4</pre><p>Yes, extreme terseness is characteristic of J--just let it go for now.  One interesting thing we can do with our original input is to build up a list of integers as long as the array.</p><pre>i. # 1 2 0 6 8 3 9
0 1 2 3 4 5 6</pre><p>(<code>#</code> is the length function.)  Stare at this for a moment, and you'll see that the result is a list of the valid indices for the input array.  So far we've got two different arrays created from the same input: <code>0 0 0 1 1 0 1</code> (where a 1 means "greater than 5") and <code>0 1 2 3 4 5 6</code> (the list of indices for the array).  Now we take a bit of a leap.  Pair these two array together: (first element of the first array, first element of the second array), etc., like this:</p><pre>(0,0) (0,1) (0,2) (1,3) (1,4) (0,5) (1,6)</pre><p>This isn't J notation; it's just a way of showing the pairings. Notice that if you remove all pairs that have a zero in the first position, then only three pairs are left.  And the second elements of those pairs make up the answer we're looking for: <code>3 4 6</code>.  It turns out that J has an operator for pairing up arrays like this, where the first element is a count and the second is a value to repeat <i>count</i> times.  Sort of a run-length expander. The key is that a count of zero can be viewed as "delete me" and a count of 1 as "copy me as is."  Or in actual J code:</p><pre>0 0 0 1 1 0 1 # 0 1 2 3 4 5 6
3 4 6</pre><p>And there's our answer--finally! (Note that <code>#</code> in this case, with an operand on each side of it, is the "expand" function.) If you're ever going to teach a beginning programming course, go ahead and learn J first, so you can remember what it's like to be an utterly confused beginner.</p><p>In the APL/J/K worlds, there's a collection of well-known <i>phrases</i> (that is, short sequences of functions) for operations like this, each made up of primitives. It's the community of programmers with the most experience working in a point-free style. Though I doubt those programmers consider themselves to be working with "an algebra of programs," as Backus envisioned, the documentation is sprinkled with snippets of code declared to be equivalent to primitives or other sequences of functions.</p><p class="s"><a href="14.html" id="perm">permalink</a> <i>December 28, 2007</i></p><h1>previously</h1><ul><li><a href=13.html>Would You Bet $100,000,000 on Your Pet Programming Language?</a><li><a href=12.html>Timings and the Punchline</a><li><a href=11.html>Revisiting "Programming as if Performance Mattered"</a><li><a href=10.html>Finally: Data Structure Constants in Erlang</a><li><a href=9.html>Two Stories of Simplicity</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>