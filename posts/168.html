<!DOCTYPE html><html lang="en"><head><title>Don't Be Distracted by Superior Technology</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Don't Be Distracted by Superior Technology</h1><p>Not long after I first learned C, I stumbled across a lesser-used language called Modula-2. It was designed by Niklaus Wirth who previously created Pascal. While Pascal was routinely put down for being awkwardly restrictive, Wirth nudged and reshaped the language into Modula-2, arguably the finest systems-level programming language of its day.</p><p>Consider that Modula-2 had the equivalent of C++ references from the start (and for the record, so did Pascal and ALGOL). Most notably, if you couldn't guess from the name, Modula-2 had a true module system that has managed to elude the C and C++ standards committees for decades.</p><p>My problem became that I had been exposed to the Right Approach to separately compiled modules, and going back to C felt backward--even broken.</p><p>When I started exploring functional programming, I used to follow the Usenet group comp.lang.functional. A common occurrence was that someone struggling with how to write programs free of destructive updates would ask a question. As the thread devolved into bickering about type systems and whatnot, someone would inevitably point out a language that gracefully handled that particular issue in a much nicer way than Haskell, ML, or Erlang.</p><p>Except that the suggested language was an in-progress research project.</p><p>The technology world is filled with cases where smart and superior alternatives exist, but their existence makes no difference because you can't use them. 1980s UNIX was incredibly stable compared to MS-DOS, but it was irrelevant if you intended to  use MS-DOS software. Clojure and Factor are wonderful languages, but if you want to write iOS games then you're better off pretending you've never heard of them. Not only are they not good options for iOS, at least not at the moment, but going so against the grain brings extra work and headaches with it.</p><p>Words like <i>better</i>, <i>superior</i>, and <i>right</i> are misleading. Yes, Modula-2 has a beautiful module system, but that's negated by being a fringe language that isn't likely to be available from the start when exciting new hardware is released. Erlang isn't as theoretically beautiful as those cutting-edge research languages, but it's been through the forge of shipping large-scale systems. What may look like warts upon first glance may be the result of pragmatic choices.</p><p>There's much more fun to be had building things than constantly being distracted by better technology.</p><p>(If you liked this, you might enjoy <a href="140.html">The Pace of Technology is Slower than You Think</a>.)</p><p class="s"><a href="168.html" id="perm">permalink</a> <i>March 3, 2013</i></p><h1>previously</h1><ul><li><a href=167.html>Simplicity is Wonderful, But Not a Requirement</a><li><a href=166.html>The Highest-Level Feature of C</a><li><a href=165.html>Sympathy for Students in Beginning Programming Classes</a><li><a href=164.html>Trapped by Exposure to Pre-Existing Ideas</a><li><a href=163.html>An Irrational Fear of Files on the Desktop</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>