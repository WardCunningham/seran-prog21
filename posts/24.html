<!DOCTYPE html><html lang="en"><head><title>Purely Functional Retrogames, Part 2</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Purely Functional Retrogames, Part 2</h1><p>(Read <a href="23.html">Part 1</a> if you missed it.)</p><p>The difficult, or at least different, part of writing a game in a purely functional style is living without global, destructive updates.  But before getting into how to deal with that, anything that can be done to reduce the need for destructive updates is going to make things easier later on.</p><p>Back when I actually wrote 8-bit games, much of my code involved updating timers and counters used for animation and special effects and so on.  At the time it made a lot of sense, given the limited math capabilities of a 6502.  In the modern world you can achieve the same by using a single clock counter that gets incremented each frame.</p><p>Ever notice how the power pills in Pac-Man blink on and off?  Let's say the game clock is incremented every 1/60th of a second, and the pills flop from visible to invisible--or the other way around--twice per second (or every 30 ticks of the clock).  The state of the pills can be computed directly from the clock value:</p><pre>pills_are_visible(Clock) -&gt;
   is_even(Clock div 30).</pre><p>No special counters, no destructive updates of any kind.  Similarly, the current frame of the animation of a Pac-Man ghost can be computed given the same clock:</p><pre>current_ghost_frame(Clock) -&gt;
   Offset = Clock rem TOTAL_GHOST_ANIMATION_LENGTH,
   Offset div TIME_PER_ANIMATION_FRAME.</pre><p>Again, no special counters and no per frame updates.  The clock can also be used for general event timers.  Let's say the bonus fruit appears 30 seconds after a level starts.  All we need is one value: the value of the clock when the level started plus 30*60.  Each frame we check to see if the clock matches that value.</p><p>None of this is specific to functional programming.  It's common in C and other languages.  (The reason it was ugly on the 6502 was because of the lack of division and remainder instructions, and managing a single global clock involved verbose 24-bit math.)</p><p>There are limits to how much a single clock value can be exploited.  You can't make every enemy in Robotron operate entirely as a function of time, because they react to other stimuli in the world, such as the position of the player.  If you think about this trick a bit, what's actually going on is that some data is entirely dependent on other data.  One value can be used to compute others.  This makes a dynamic world be a whole lot more static than it may first seem.</p><p>Getting away from clocks and timing, there are other hidden dependencies in the typical retro-style game.  In a procedural implementation of Pac-Man, when Pac-Man collides with a blue ghost, a global score is incremented.  This is exactly the kind of hidden update that gets ugly with a purely functional approach.  Sure, you could return some special data indicating that the score should change, but there's no need.</p><p>Let's say that each ghost has a state that looks like this: {State_name, Starting_time}.  When a ghost has been eaten and is attempting to return to the box in the center of the maze, the state might be {return_to_box, 56700}.  (56700 was the value of the master clock when the ghost was eaten.) Or it might be more fine-grained than that, but you get the idea.  The important part is that there's enough information here to realize that a ghost was eaten during the current frame: if the state name is "return_to_box" and the starting time is the same as the current game clock.  A separate function can scan through the ghost states and look for events that would cause a score increase.</p><p>The same technique also applies to when sounds are played.  It's not something that has to be a side effect of the ghost behavior handling code.  There's enough implicit information, given the state of the rest of the world, to make decisions about when sounds should be played. Using the example from the preceding paragraph, the same criteria for indicating a score increase can also be used to trigger the "ghost eaten" sound.</p><p><a href="25.html">Part 3</a></p><p class="s"><a href="24.html" id="perm">permalink</a> <i>April 19, 2008</i></p><h1>previously</h1><ul><li><a href=23.html>Purely Functional Retrogames, Part 1</a><li><a href=22.html>My Road to Erlang</a><li><a href=21.html>Slumming with BASIC Programmers</a><li><a href=20.html>In Praise of Non-Alphanumeric Identifiers</a><li><a href=19.html>Five Memorable Books About Programming</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>