<!DOCTYPE html><html lang="en"><head><title>Fun vs. Computer Science</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Fun vs. Computer Science</h1><p>I've spent most of my career working on games, either programming or designing them or both. Games are weird, because everything comes down to this nebulous thing called <i>fun</i>, and there's a complete disconnect between fun and most technical decisions:</p><p>Does choosing C++14 over C++11 mean the resulting game is more fun?</p><p>Does using a stricter type system mean the game is more fun?</p><p>Does using a more modern programming language mean the game is more fun?</p><p>Does favoring composition over inheritance mean the game is more fun?</p><p>Now you could claim that some of this tech would be more fun <i>for the developer</i>. That's a reasonable, maybe even important point, but there's still a hazy at best connection between this kind of "developer fun" and "player fun."</p><p>A better argument is that some technologies may result in the game being more stable and reliable. Those two terms should be a prerequisite to fun, and even though people struggle along--and have fun with--buggy games (e.g., Pokemon Go), I'm not going to argue against the importance of reliability. Think about all the glitchiness and clunkiness you experience every day, from spinning cursors, to Java tricking you into installing the Ask toolbar, to an app jumping into the foreground so you click on the wrong thing. Now re-watch <i>The Martian</i> and pretend all the computers in the movie work like your desktop PC. RIP Matt Damon.</p><p>The one thing that <i>does</i> directly make a game more fun is decreased iteration time. Interactive tweaking beats a batch compile and re-launch every time, and great ideas can come from on the fly experimentation. The productivity win, given the right tools, is 10x or more, and I can't emphasize this enough.</p><p>And yet this more rapid iteration, which is so important to me, does not seem to be of generally great importance. It's not something that comes up in computer sciencey discussions of development technologies. There's much focus on sophisticated, and slow, code optimization, but turnaround time is much more important in my work. A certain circle of programmers puts type systems above all else, yet in Bret Victor's inspirational <a href="https://vimeo.com/36579366">Inventing on Principle</a> talk from 2012, he never mentioned type systems, not once, but oh that interactivity.</p><p>I realize that we're heading toward the ultimate software engineer dream of making a type-checked change that's run through a proven-correct compiler that does machine-learning driven, whole program optimization...but it's going the exact opposite of the direction I want. It's not helping me in my quest for creating fun.</p><p>For the record, I just picked those buzzwords out of my mind. I'm not criticizing static type checking or any of those things, or even saying that they preclude interactive iteration (see Swift's playgrounds, for example). They might make things harder though, if they necessitate building a new executable of the entire game for every little change.</p><p>Interactivity, I may have to grudgingly accept, is not trendy in computer science circles.</p><p>(If you liked this, you might enjoy <a href="194.html">You Don't Read Code, You Explore It</a>.)</p><p class="s"><a href="221.html" id="perm">permalink</a> <i>July 26, 2016</i></p><h1>previously</h1><ul><li><a href=220.html>Evolution of an Erlang Style</a><li><a href=219.html>Death of a Language Dilettante</a><li><a href=218.html>Moving Beyond the OOP Obsession</a><li><a href=217.html>On the Madness of Optimizing Compilers</a><li><a href=216.html>Messy Structs/Classes in a Functional Style</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>