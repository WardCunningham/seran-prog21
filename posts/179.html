<!DOCTYPE html><html lang="en"><head><title>How much memory does malloc(0) allocate?</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>How much memory does malloc(0) allocate?</h1><p>On most systems, this little C program will soak up all available memory:</p><pre>while (1) {
   malloc(0);
}</pre><p>so the answer is not the obvious "zero." But before getting into <code>malloc(0)</code>, let's look at the simpler case of <code>malloc(1)</code>.</p><p>There's an interesting new C programmer question about <code>malloc</code>: "Given a pointer to dynamically allocated memory, how can I determine how many bytes it points to?" The answer, rather frustratingly, is "you can't." But when you call <code>free</code> on that same pointer, the memory allocator knows how big the block is, so it's stored <i>somewhere</i>. That somewhere is commonly adjacent to the allocated memory, along with any other implementation-specific data needed for the allocator.</p><p>In the popular <code>dlmalloc</code> implementation, between 4 and 16 bytes of this overhead are added to a request, depending on how the library is configured and whether pointers are 32 or 64 bits. 8 bytes is a reasonable guess for a 64-bit system.</p><p>To complicate matters, there's a minimum block size that can be returned by <code>malloc</code>. Alignment is one reason. If there's an integer size secretly prepended to each block, then it doesn't make sense to allocate a block smaller than an integer. But there's another reason: when a block is freed, it gets tracked somehow. Maybe it goes into a linked list, maybe a tree, maybe something fancier. Regardless, the pointers or other data to make that work have to go somewhere, and inside the just-freed block is a natural choice.  </p><p>In <code>dlmalloc</code>, the smallest allowed allocation is 32 bytes on a 64-bit system. Going back to the <code>malloc(1)</code> question, 8 bytes of overhead are added to our need for a single byte, and the total is smaller than the minimum of 32, so that's our answer: <code>malloc(1)</code> allocates 32 bytes.</p><p>Now we can approach the case of allocating zero bytes. It turns out there's a silly debate about the right thing to do, and it hasn't been resolved, so technically allocating zero bytes is implementation-specific behavior. One side thinks that <code>malloc(0)</code> should return a null pointer and be done with it. It works, if you don't mind a null return value serving double duty. It can either mean "out of memory" or "you didn't request any memory."</p><p>The more common scheme is that <code>malloc(0)</code> returns a unique pointer. You shouldn't dereference that pointer because it's conceptually pointing to zero bytes, but we know from our adventures above that at least <code>dlmalloc</code> is always going to allocate a 32 byte block on a 64-bit system, so that's the final answer: it takes 32 bytes to fulfill your request for no memory.</p><p>[EDIT: I modified the last two paragraphs to correct errors pointed out in email and a discussion thread on <a href="http://www.reddit.com/r/programming/comments/1iv9nz/how_much_memory_does_malloc0_allocate/">reddit</a>. Thank you for all the feedback!] </p><p>(If you liked this, you might enjoy <a href="141.html">Another Programming Idiom You've Never Heard Of</a>.)</p><p class="s"><a href="179.html" id="perm">permalink</a> <i>July 22, 2013</i></p><h1>previously</h1><ul><li><a href=178.html>Getting Past the Cloning Instinct</a><li><a href=177.html>Organizational Skills Beat Algorithmic Wizardry</a><li><a href=176.html>Tips for Writing Functional Programming Tutorials</a><li><a href=175.html>Getting Comfortable with the Softer Side of Development</a><li><a href=174.html>Flickr's Redesign is a Series of Evolutionary Changes</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>