<!DOCTYPE html><html lang="en"><head><title>Five Memorable Books About Programming</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Five Memorable Books About Programming</h1><p>I've read the classics--<i>Structure and Interpretation of Computer Programs</i>, <i>Paradigms of Artificial Intelligence Programming</i>--but I'd like to highlight some of the more esoteric books which affected my thinking.</p><p><i><b>Zen of Assembly Language</b><br>
Michael Abrash, 1990</i></p><p>I spent much of the 1980s writing 8-bit computer games (which you can <a href="http://www.dadgum.com/giantlist/archive/hague.html">read about</a> if you like).  Odd as it may seem in retrospect, considering the relative power of an 8-bit 6502 running at sub 2 MHz, I wasn't obsessed with optimizing for performance.  If anything, I wanted the code to be <i>small</i>, a side effect of using a line-based editor and writing programs that someone would have to painstakingly type in from a magazine listing.  Pages of DATA 0AFF6CA900004021... ugh.</p><p>Right when that period of my life came to a close, along came <i>Zen of Assembly Language</i>, by an author I had never heard of, which dissected, explained, and extended the self-taught tricks from my years as a lone assembly hacker. Even though Abrash was focused on the 8086 and not the 6502, it felt like the book was written personally to me.</p><p>This is also one of the most bizarrely delayed technical book releases I can recall.  The majority of the book was about detailed optimization for the 8088 and 8086, yet it was published when the 80486 was showing up in high-end desktop PCs.</p><p><i><b>Scientific Forth</b><br>
Julian Noble, 1992</i><br>
<i><b>Fractals, Visualization, and J</b><br>
Clifford Reiter, 2000</i></p><p>These two books are about entirely different subjects.  One is about pure scientific computation.  The other is about generating images.  Each uses a different, wildly non-mainstream language for the included code.</p><p>And yet these two books follow the same general approach, one I wish were more commonly used.  Superficially, the authors have written introductions to particular programming languages (which is why the language name is in the title).  But in reality it's more that each author has an area of deep expertise and has found a language that enables experimenting with and writing code to solve problems in that field.  As such, there aren't forced examples and toy problems, but serious, non-trivial programs that show a language in actual use.  Dr. Noble demonstrates how he uses Forth for hardcore matrix work and, when he realizes that RPN notation isn't ideal in all circumstances, develops a translator from infix expressions to Forth.  Clifford Reiter jumps into image processing algorithms, plus veers into lighter weight diversions with titles like "R/S Analysis, the Hurst Exponent, and Sunspots."</p><p>Both books are wonderful alternatives to the usual "Learning Programing Language of the Month" texts.  Sadly, Julian Noble died in 2007.</p><p><i><b>Programmers At Work</b><br>
Susan Lammers, 1986</i></p><p>I used to soak up printed interviews with programmers and game designers (and typically game designers were programmers as well).  I was enthralled by Levy's <i>Hackers</i>, more the game development chapter than the rest.  <i>Programmers At Work</i> was in the same vein: philosophies, ideas, and experiences directly from an odd mix of famous and quirky programmers.  But the book wasn't primarily about tech.  It was about creativity.  Most of the people interviewed didn't have degrees in computer science.  There wasn't an emphasis on math, proving programs correct, lambda calculus--just people coming up with ideas and implementing them.  And the game connection was there: Jaron Lanier talking about the psychedelic <b>Moon Dust</b> for the Commodore 64, Bill Budge's bold (and still unfulfilled) plan to build a "Construction Set Construction Set."</p><p>Lammers's book was the model I used when I put together <a href="http://www.dadgum.com/halcyon">Halcyon Days</a>.  I also pulled <i>Hackers</i> into the mix by interviewing John Harris about his dissatisfaction with Levy's presentation of him.  In an odd twist of fate, <i>Programmers at Work</i> and <i>Halcyon Days</i> were packaged together on a single CD sold through the Dr. Dobb's Journal library.  The pairing has been around for ten years and is still available, much to my surprise.</p><p><i><a href="http://thinking-forth.sourceforge.net/"><b>Thinking Forth: A Language and Philosophy for Solving Problems</b></a><br>
Leo Brodie, 1984</i></p><p>Yes, another book about Forth.</p><p>But this one is worth reading less for the Forth and more because it's one of the few books about how to decompose problems and structure code.  You'd think this book was written by Fowler and friends, until you realize it's from the mid-1980s.  That Brodie uses "factor" (which originated in the Forth community) instead of "refactor" is also a giveaway.  What's impressive here is there's no OOP, no discussion of patterns, no heavy terminology.  It's a book about understanding what you're trying to achieve, avoiding redundancy, and writing dead simple code.</p><p>It's worth it for the Forth, too, especially the interspersed bits of wisdom from experts, including Forth creator Chuck Moore.</p><p class="s"><a href="19.html" id="perm">permalink</a> <i>February 18, 2008</i></p><h1>previously</h1><ul><li><a href=18.html>Back to the Basics of Functional Programming</a><li><a href=17.html>Don't Structure Data All The Way Down</a><li><a href=16.html>Garbage Collection in Erlang</a><li><a href=15.html>Why Garbage Collection Paranoia is Still (sometimes) Justified</a><li><a href=14.html>Functional Programming Archaeology</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>