<!DOCTYPE html><html lang="en"><head><title>A Concurrent Language for Non-Concurrent Software</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>A Concurrent Language for Non-Concurrent Software</h1><p>Occasionally I get asked why, as someone who uses Erlang extensively, do I rarely talk about concurrency?</p><p>The answer is because concurrency is not my primary motivation for using Erlang.</p><p>Processes themselves are wonderful, and I often use them as a way to improve modularity. Rather than passing the state of the world all over the place, I can spin off processes that capture a bit of it. This works surprisingly well, but it's just a coarser-grained version of creating objects in Python or other languages. Most of the time when I send a message to another process, my code sits and waits for the result to come back, which is hardly "concurrency."</p><p>Suppose Erlang didn't have processes at all. Is there still anything interesting about the language? To me, yes, there is. I <a href="22.html">first tried</a> functional programming to see if I could think at a higher level, so I could avoid a whole class of concerns that I was tired of worrying about. Erlang is further down the purely functional road than most languages, giving the benefits that come with that, but at the same time there's a divergence from the hardcore, theoretical beauty of Haskell. There's no insistence on functions taking a single value, there isn't a typing-first viewpoint. The result is being able to play fast and loose with a handful of data types--especially atoms--and focus on how to arrange and rearrange them in useful ways.</p><p>(Okay, there are some small things I like about Erlang too, such as being able to introduce named values without creating a new scope that causes creeping indentation. It's the only functional language I've used that takes this simple approach.)</p><p>The angle of writing code that doesn't involve micromanaging destructive updates takes some time to sink in. Possibly too long; something almost always ignored when presenting a pathologically beautiful one-liner that makes functional programming look casually effortless. There are a number of techniques that aren't obvious, that aren't demonstrated in tutorials. I <a href="7.html">wrote about one</a> in 2007. And here's another:</p><p>Lists in Erlang--and Haskell and Scheme--are singly-linked. Given a list, you can easily get the next element. Getting the <i>previous</i> element looks impossible; there's no back pointer to follow. But that's only true if you're looking at the raw definition of lists. It's easy if you add some some auxiliary data. When you step forward, remember the element you just moved away from. When you step back, just grab that element. The data structure looks like this:</p><pre>{Previous_Items, Current_List}</pre><p>To move through a list, start out with <code>{[], List}</code>. You can step forward and back with two functions:</p><pre>forward({Prev, [H|T]}) -&gt;
   {[H|Prev], T}.

back({[H|T], L}) -&gt;
   {T, [H|L]}.</pre><p>Wait, isn't that cheating? Creating a new list on the fly like that? No, that's the <i>point</i> of being free from thinking about managing memory or even instantiating classes.</p><p class="s"><a href="81.html" id="perm">permalink</a> <i>October 17, 2010</i></p><h1>previously</h1><ul><li><a href=80.html>Advice to Aimless, Excited Programmers</a><li><a href=79.html>Erlang vs. Unintentionally Purely Functional Python</a><li><a href=78.html>Common Sense, Part 1</a><li><a href=77.html>Personal Programming</a><li><a href=76.html>Stop the Vertical Tab Madness</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>