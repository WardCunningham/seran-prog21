<!DOCTYPE html><html lang="en"><head><title>In Praise of Non-Alphanumeric Identifiers</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>In Praise of Non-Alphanumeric Identifiers</h1><p>Here's a common definition of what constitutes a valid identifier in many programming languages:</p><blockquote><p>The first character must be any letter (A-Z, a-z) or an underscore.  Subsequent characters, if any, must be a letter, digit (0-9), or an underscore.</p></blockquote><p>Simple enough.  It applies to C, C++, ML, Python, most BASICs, most custom scripting languages (e.g., Game Maker Language).  But of course there's no reason for this convention other than being familiar and expected.</p><p>One of my favorite non-alphanumeric characters for function names is "?".  Why say <code>is_uppercase</code> (or <code>IsUppercase</code> or <code>isUppercase</code>) when you can use the more straightforward <code>Uppercase?</code> instead?  That's standard practice in Scheme and Forth, and I'm surprised it hasn't caught on in all new languages.</p><p>(As an aside, in Erlang you can use any atom as a function name.  You can put non-alphanumeric characters in an atom if you remember to surround the entire name with single quotes.  It really does work to have a function named <code>'uppercase?'</code> though the quotes make it clunky.)</p><p>Scheme's "!" is another good example.  It's not mnemonic, and it doesn't carry the same meaning as in English punctuation.  Instead it was arbitrarily designated a visual tag for "this function destructively updates data": <code>set!</code>, <code>vector-set!</code>.  That's more concise than any other notation I can think of ("-m" for "mutates"? Yuck).</p><p>Forth goes much further, not only allowing any ASCII character in identifiers, but there's a long history of lexicographic conventions.  The fetch and store words--"@" and "!"--are commonly appended to names, so <code>color@</code> is read as "color fetch."  That's a nice alternative to "get" and "set" prefixes.  The Forthish <code>#strings</code> beats "numStrings" any day.  Another Forth standard is including parentheses in a name, as in <code>(open-file)</code>, to indicate that a word is low-level and for internal use only.</p><p>And then there are clever uses of characters in Forth that make related words look related, like this:</p><pre>open{ write-byte write-string etc. }close</pre><p>The brace is part of both <code>open{</code> and <code>}close</code>.  There no reason the braces couldn't be dropped completely, but they provide a visual cue about scope.</p><p class="s"><a href="20.html" id="perm">permalink</a> <i>February 25, 2008</i></p><h1>previously</h1><ul><li><a href=19.html>Five Memorable Books About Programming</a><li><a href=18.html>Back to the Basics of Functional Programming</a><li><a href=17.html>Don't Structure Data All The Way Down</a><li><a href=16.html>Garbage Collection in Erlang</a><li><a href=15.html>Why Garbage Collection Paranoia is Still (sometimes) Justified</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>