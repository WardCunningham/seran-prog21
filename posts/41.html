<!DOCTYPE html><html lang="en"><head><title>Let's Take a Trivial Problem and Make it Hard</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Let's Take a Trivial Problem and Make it Hard</h1><p>Here's a simple problem:  Given a block of binary data, count the frequency of the bytes within it.  In C, this could be a homework assignment for an introductory class.  Just zero out an array of 256 elements, then for each byte increment the appropriate array index.  Easy.</p><p>Now write this in a purely functional way, with an efficiency close to that of the C implementation.</p><p>It's easy to do a straightforward translation to Erlang, using tail recursion instead of a <code>for</code> loop, like this:</p><pre>freq(B) when is_binary(B) -&gt;
   freq(B, erlang:make_tuple(256, 0)).

freq(&lt;&lt;X, Rest/binary&gt;&gt;, Totals) -&gt;
   I = X + 1,
   N = element(I, Totals),
   freq(Rest, setelement(I, Totals, N + 1));
freq(&lt;&lt;&gt;&gt;, Totals) -&gt;
   Totals.</pre><p>But of course in the name of purity and simplicity, <code>setelement</code> copies the entire <code>Totals</code> tuple, so if there are fifty million bytes, then the 256 element <code>Totals</code> is copied 50 million times.  It's simple, but it's not the right approach.</p><p>"Blame the complier" is another easy option.  If it could be determined that the <code>Totals</code> tuple can be destructively updated, then we're good.  Note that the garbage collector in the Erlang runtime is based on the assumption that pointers in the heap always point toward older data, an assumption that could break if a tuple was destructively updated with, say, a list value.  So not only would the compiler have to deduce that that the tuple is only used locally, but it would also have to verify that only non-pointer values (like integers and atoms) were being passed in as the third parameter of <code>setelement</code>.  This is all possible, but it doesn't currently work that way, so this line of reasoning is a dead end for now.</p><p><code>Totals</code> could be switched from a tuple to a tree, which might or might not be better than the <code>setelement</code> code, but there's no way it's in the same ballpark as the C version.</p><p>What about a different algorithm?  Sort the block of bytes, then count runs of identical values.  Again, just the suggestion of sorting means we're already off track.</p><p>Honestly, I don't know the right answer.  In Erlang, I'd go for one of the imperative efficiency hacks, like ets tables, but let's back up a bit.  The key issue here is that there are some fundamental assumptions about what "purely functional" means and the expected features in functional languages.</p><p>In array languages, like <a href="http://www.jsoftware.com">J</a>, this type of problem is less awkward, as it's closer to what they were designed for.  If nothing else, reference counted arrays make it easier to tell when destructive updates are safe.  And there's usually some kind of classification operator, one that would group the bytes by value for easy counting. That's still not going to be as efficient as C, but it's clearly higher-level than the literal Erlang translation.</p><p>A more basic question is this: "Is destructively updating a local array a violation of purely functionalness?"  OCaml allows destructive array updates and C-like control structures.  If a local array is updated inside of an OCaml function, then the result copied to a non-mutable array at the end, is there really anything wrong with that?  It's not the same as randomly sticking your finger inside a global array somewhere, causing a week's worth of debugging.  In fact, it looks <i>exactly the same as the purely functional version</i> from the caller's point of view.</p><p>Perhaps the sweeping negativity about destructive updates is misplaced.</p><p class="s"><a href="41.html" id="perm">permalink</a> <i>May 4, 2009</i></p><h1>previously</h1><ul><li><a href=40.html>On Being Sufficiently Smart</a><li><a href=39.html>How My Brain Kept Me from Co-Founding YouTube</a><li><a href=38.html>Puzzle Languages</a><li><a href=37.html>Revisiting "Purely Functional Retrogames"</a><li><a href=36.html>Accidentally Introducing Side Effects into Purely Functional Code</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>