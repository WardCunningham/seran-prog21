<!DOCTYPE html><html lang="en"><head><title>A Personal History of Compilation Speed, Part 1</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>A Personal History of Compilation Speed, Part 1</h1><p>The first compiled language I used was the <a href="http://en.wikipedia.org/wiki/Atari_Assembler_Editor">Assembler Editor</a> cartridge for the Atari 8-bit computers.  Really, it had the awful name "Assembler Editor." I expect some pedantic folks want to interject that an assembler is not a compiler.  At one time I would have made that argument myself.  But there was a very clear divide between editing 6502 code and running it, a divide that took time to cross, when the textual source was converted into machine-runnable form.  Contrast that to Atari BASIC, the only language I knew previously, which didn't feature a human-initiated conversion step and the inevitable time it took.</p><p>Conceptually, the Assembler Editor was a clever design.  Source code was entered line by line, even using line numbers, just like BASIC.  The assembler could compile the source straight from memory and create object code in memory, with no disk access to speak of.  The debugger was right there, too, resident in memory, setting the stage for what looked like an efficient and tightly integrated development system.</p><p>Except for whatever reason, the assembler was impressively slow, and it got disproportionately slower as program size increased.  A linear look-up in the symbol table?  Some kind of N-squared algorithm buried in there?  Who knows, but I remember waiting over seven minutes for a few hundred lines of code to assemble.  Atari knew this was a problem, because there was a note in the manual about it only being suitable for small projects.  They offered the friendly advice of purchasing a more expensive product, the Atari Macro Assembler (which was a standalone assembler, not an integrated environment).</p><p>Instead I upgraded to <a href="http://en.wikipedia.org/wiki/MAC/65">MAC/65</a>, a third party alternative that followed the formula set by the Assembler Editor: cartridge-based for fast booting, BASIC-like editor and assembler and debugger all loaded into memory at once.  MAC/65 was popular among assembly coders primarily on its reputation for quick assembly times.  And quick it was.</p><p>Almost certainly the slowness of the Assembler Editor was because of a bad design decision, one not present in MAC/65.  But MAC/65 went one step further: source code was parsed and tokenized after each line was entered.  For example, take this simple statement:</p><pre>LDA #19   ; draw all bonus items</pre><p>It takes a good amount of work, especially on a sub-2MHz processor, to pick that apart.  "LDA" needs to be scanned and looked-up somewhere.  "19" needs to be converted to binary.  The MAC/65 approach was to do much of this at edit-time, storing the tokenized representation in memory instead of the raw text.</p><p>In the above example, the tokenized version could be reduced to a byte indicating "load accumulator immediate," plus the binary value 19 (stored as a byte, not as two ASCII characters), and then a token indicating the rest of the line was a comment and could be ignored at assembly time.  When the user viewed the source code, it had to be converted from the tokenized form back into text.  This had the side-effect of enforcing a single standard for indentation style, whether or not there was a space after the comment semicolon, and so on.</p><p>When my Atari 8-bit days ended, and I moved to newer systems, I noticed two definite paths in assembler design.  There were the traditional, lumbering assemblers that ran as standalone applications, which almost always required a final linking step.  These were usually slow and awkward, seemingly designed as back-ends to high-level language compilers, not meant to be used directly by programmers.  And then there were the lightning-fast assemblers, often integrated with editors and debuggers in the tradition of the Assembler Editor and MAC/65.  For dedicated assembly programmers during the Amiga and Atari ST years, those were clearly the way to go.</p><p>By that time, except when there was no alternative, I was using compilers for higher-level languages.  And I was wondering if the "slow, lumbering" and "lightning fast" split applied to those development systems as well.</p><p><a href="47.html">Part 2</a></p><p class="s"><a href="45.html" id="perm">permalink</a> <i>August 2, 2009</i></p><h1>previously</h1><ul><li><a href=44.html>Want People to Use Your Language Under Windows? Do This.</a><li><a href=43.html>How to Crash Erlang</a><li><a href=42.html>Digging Deeper into Sufficiently Smartness</a><li><a href=41.html>Let's Take a Trivial Problem and Make it Hard</a><li><a href=40.html>On Being Sufficiently Smart</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>