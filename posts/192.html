<!DOCTYPE html><html lang="en"><head><title>Range-Checks and Recklessness</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Range-Checks and Recklessness</h1><p>Here's an odd technical debate from the 1980s: Should compiler-generated checks for "array index out of range" errors be left in production code?</p><p>Before C took over completely, with its loose accessing of memory as an offset from any pointer, there was a string of systems-level languages with deeper treatment of arrays, including the ALGOL family, PL/1, Pascal, Modula-2, and Ada. Because array bounds were known, every indexing operation, such as:</p><pre>frequency[i] = 0</pre><p>could be checked at runtime to see if it fell within the extents of the array, exiting the program with an error message otherwise.</p><p>This was such a common operation that hardware support was introduced with the 80286 processor in the form of the <code>bound</code> instruction. It encapsulated the two checks to verify an index was between the upper and lower bounds of an array. Wait, wasn't the lower bound always zero? Often not. In Pascal, you could have declarations like this:</p><pre>type Nineties = array[1990..1999] of integer;</pre><p>Now back to the original question of whether the range checks should live on in shipping software. That error checking is great during development was not controversial, but opinions after that were divided. One side believed it wasteful to keep all that byte and cycle eating around when you knew it wasn't needed. The other group claimed you could never guarantee an absence of bugs, and wouldn't it be better to get some kind of error message than to silently corrupt the state of the application?</p><p>There's also a third option, one that wasn't applicable to simpler compilers like <a href="116.html">Turbo Pascal</a>: have the compiler determine an index is guaranteed to be valid and don't generate range checking code.</p><p>This starts out easy. Clearly the constant in <code>Snowfall[1996]</code> is allowed for a variable of type <code>Nineties</code>. Replace "1996" with a variable, and it's going to take more work. If it's the iteration variable in a <code>for</code> loop, and we can ensure that the bounds of the loop are between 1990 and 1999 inclusive, then the range checks in the loop body can be omitted.</p><p>Hmmm...what if the <code>for</code> loop bounds aren't constants? What if they're computed by a function in another module? What if there's math done on the indices? What if it's a less structured <code>while</code> loop? Is this another case of needing a <a href="40.html">sufficiently smart compiler</a>? At what point do diminishing returns kick in, and the complexity of implementation makes it hard to have faith that the solution is working correctly?</p><p>I set out to write this not for the technical details and trivia, but more about how my thinking has changed. When I first ran across the range-check compiler option, I was fresh out of the school of assembly language programming, and my <a href="50.html">obsessive, instruction-counting brain</a> was much happier with this setting turned off. These days I can't see that as anything but reckless. Not only would I happily leave it enabled, but were I writing the compiler myself I'd only remove the checks in the most obvious and trivial of cases. It's not a problem worth solving.</p><p class="s"><a href="192.html" id="perm">permalink</a> <i>March 22, 2014</i></p><h1>previously</h1><ul><li><a href=191.html>Popular iOS Games That Could Have Been Designed for 8-Bit Systems</a><li><a href=190.html>You Don't Want to Think Like a Programmer</a><li><a href=189.html>A Worst Case for Functional Programming?</a><li><a href=188.html>Success Beyond the Barrier of Full Understanding</a><li><a href=187.html>Optimization in the Twenty-First Century</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>