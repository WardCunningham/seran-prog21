<!DOCTYPE html><html lang="en"><head><title>Accidentally Introducing Side Effects into Purely Functional Code</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Accidentally Introducing Side Effects into Purely Functional Code</h1><p>It's easy to taint even purely functional languages by reintroducing side-effects.  Simply have each function take an additional parameter representing the global state of the world--a tree of key/value pairs, for example--and have each function return a new state of the world.  This is not news.  It's an intentionally pathological case, not something I'd ever consider implementing.</p><p>What's more surprising is how easy it is to <i>accidentally</i> introduce side-effects.</p><p>For the <a href="23.html">Purely Functional Retrogames</a> series, I wrote code that operated on a list of game entities:</p><pre>[A, B, C, D,...]</pre><p>Each element was a self-contained unit of sorts: an ID, x/y position, current state.  Using this list of entities to build a new version for the next game frame was a simple map operation.  The ID and state for each entity were used to call the correct transformation function for that entity.</p><p>Each of these transformations had three possible outcomes: a new entity would be returned with a different position and/or state, an entity could delete itself, or an entity could create some new entities (think of dropping a bomb or firing a shot).  All three of these can be handled by having each transformation function return a list.</p><p>For example, if the original list was:</p><pre>[A, B, C, D]</pre><p>and entity "B" deleted itself, and entity "C" created four new entities in addition to a new version of itself, then the returned values might look like this:</p><pre>A =&gt; [A1]
B =&gt; []
C =&gt; [C1, New1, New2, New3, New4]
D =&gt; [D1]</pre><p>and the new overall list of entities would be:</p><pre>[A1, C1, New1, New2, New3, New4, D1]</pre><p>Well, that's not quite right.  It's actually a list of lists:</p><pre>[A1, [], [C1, New1, New2, New3, New4], [D1]]</pre><p>and the individual lists need to be appended together to give the proper result.  The append operation creates a brand new list, which means that the time and memory spent creating the individual result lists were wasted.  They were just stepping stones to the real result.  This almost certainly isn't going to be a significant inefficiency, but there's a pretty way around it: pass an accumulator list in and out of each transformation function.  Now the three cases listed above neatly map to three operations:</p><p>1. To transform an entity into the next version of itself, simply prepend the new entity to the accumulator list.</p><p>2. To delete an entity, do nothing.  Simply return the accumulator.</p><p>3. To create new entities, prepend each one to the accumulator.</p><p>No extra work is involved.  We never build-up temporary lists and discard them immediately.</p><p>But this pretty little solution has one unintended flaw.  By passing in the accumulator list, we're giving <b>full access</b> to previous computations to each of the entity transformation functions. Even worse, each of these functions can <b>arbitrarily transform</b> this list, not only prepending values but also removing existing values or changing the order of them.  (No destructive updates need occur, just the returning of a different list.) In theory we could write code that uses the list to make decisions: if the head of the accumulator is an entity of type "E," then spawn a new entity at the same position as E.  Now the entire process is order dependent...ugh.</p><p>In theory.  The "flaw" here assumes that each function is going to do more than either leave the accumulator untouched or prepend values to it, that the programmer of a function may intentionally go rogue and look to sabotage the greater good. It still <i>could</i> open the door to bugs: imagine if a dozen people were all writing these transformation functions independently.  Someone will make a mistake at some point.</p><p>Either way, the same side effects possible in imperative languages were accidentally introduced into pure functions.</p><p class="s"><a href="36.html" id="perm">permalink</a> <i>December 14, 2008</i></p><h1>previously</h1><ul><li><a href=35.html>Timidity Does Not Convince</a><li><a href=34.html>Macho Programming</a><li><a href=33.html>Understanding What It's Like to Program in Forth</a><li><a href=32.html>Kilobyte Constants, a Simple and Beautiful Idea that Hasn't Caught On</a><li><a href=31.html>Functional Programming Went Mainstream Years Ago</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>