<!DOCTYPE html><html lang="en"><head><title>A Peek Inside the Erlang Compiler</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>A Peek Inside the Erlang Compiler</h1><p>Erlang is a complex system, and I can't do its inner workings justice in a short article, but I wanted to give some insight into what goes on when a module is compiled and loaded. As with most compilers, the first step is to convert the textual source to an abstract syntax tree, but that's unremarkable. What is interesting is that the code goes through three major representations, and you can look at each of them.</p><p>Erlang is unique among functional languages in its casual scope rules. You introduce variables as you go, without fanfare, and there's no creeping indentation caused by explicit scopes. Behind the scenes that's too quirky, so the syntax tree is converted into Core Erlang. Core Erlang looks a lot like Haskell or ML with all variables carefully referenced in "let" statements. You can see the Core Erlang representation of a module with this command from the shell:</p><pre>c(example, to_core).</pre><p>The human-readable Core Erlang for the <code>example</code> module is written to <code>example.core</code>.</p><p>The next big transformation is from Core Erlang to code for the register-based BEAM virtual machine. BEAM is poorly documented, but it's a lot like the <a href="http://en.wikipedia.org/wiki/Warren_Abstract_Machine">Warren Abstract Machine</a> developed for Prolog (but without the need for backtracking). BEAM isn't terribly hard to figure out if you write short modules and examine them with:</p><pre>c(example, 'S').</pre><p>The disassembled BEAM code for the <code>example</code> module is written to <code>example.S</code>. The key to understanding BEAM is that there are two sets of registers: one for passing parameters ("x" registers) and one for use as locals within functions ("y" registers).</p><p>Virtual BEAM code is the final output of the compiler, but it's still not what gets executed by the system. If you look at the source for the Erlang runtime, you'll see that <code>beam_load.c</code> is over six thousand lines of code. Six thousand lines to load a module? That's because the beam loader is doing more than its name lets on.</p><p>There's an optimization pass on the virtual machine instructions, specializing some for certain situations and combining others into superinstructions. To check if a value is a tuple of three elements is accomplished with a pair of BEAM operations: <code>is_tuple</code> and <code>is_arity</code>. The BEAM loader turns these into one superinstruction: <code>is_tuple_of_arity</code>. You can see this condensed representation of BEAM code with:</p><pre>erts_debug:df(example).</pre><p>The disassembled code is written to <code>example.dis</code>. (Note that the module must be loaded, so compile it before giving the above command.)</p><p>The loader also turns the BEAM bytecode into <a href="http://en.wikipedia.org/wiki/Threaded_code">threaded code</a>: a list of addresses that get jumped to in sequence. There's no "Now what do I do with this opcode?" step, just fetch and jump, fetch and jump. If you want to to know more about threaded code, look to the <a href="33.html">Forth</a> world.</p><p>Threaded code takes advantage of the <a href="http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html">labels as values</a> extension of gcc. If you build the BEAM emulator with another compiler like Visual C++, it falls back on using a giant <code>switch</code> statement for instruction dispatch and there's a significant performance hit.</p><p>(If you liked this, you might enjoy <a href="70.html">A Ramble Through Erlang IO Lists</a>.)</p><p class="s"><a href="127.html" id="perm">permalink</a> <i>February 6, 2012</i></p><h1>previously</h1><ul><li><a href=126.html>Four Levels of Idea Theft</a><li><a href=125.html>Pretend This Optimization Doesn't Exist</a><li><a href=124.html>Virtual Joysticks and Other Comfortably Poor Solutions </a><li><a href=123.html>Recovering From a Computer Science Education</a><li><a href=122.html>Follow-up to "A Programming Idiom You've Never Heard Of"</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>