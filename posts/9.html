<!DOCTYPE html><html lang="en"><head><title>Two Stories of Simplicity</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Two Stories of Simplicity</h1><p>In response to <a href="6.html">Sending modern languages back to 1980s game programmers</a>, one of the questions I received was "Did any 8-bit coders ever use more powerful computers for development?"  Sure!  The <a href="http://en.wikipedia.org/wiki/VAX">VAX</a> and <a href="http://en.wikipedia.org/wiki/PDP-11">PDP-11</a> and other minicomputers were available at the time, though expensive, and some major developers made good use of them, cross-compiling code for the lowly Atari 800 and Apple II.  But there was something surprising about some of these systems:</p><p>It was often slower to cross-assemble a program on a significantly higher-specced machine like the VAX than it was to do the assembly on a stock 8-bit home computer.</p><p>Part of the reason is that multiple people were sharing a single VAX, working simultaneously, but the Apple II user had the whole CPU available for a single task. There was also the process of transferring the cross-assembled code to the target hardware, and this went away if the code was actually built on the target. And then there were inefficiencies that built up because the VAX was designed for large-scale work: more expensive I/O libraries, more use of general purpose tools and code.</p><p>For example, a VAX-hosted assembler might dynamically allocate symbols and other data on the heap, something typically not used on a 64K home computer. Now a heap manager--what malloc sits on top of--isn't a trivial bit of code.  More importantly, you usually can't predict how much time a request for a block of memory will take to fulfill.  Sometimes it may be almost instantaneous, other times it may take thousands of cycles, depending on the algorithms used and current state of the heap. Meanwhile, on the 8-bit machine, those thousands of cycles are going directly toward productive work, not solving the useful but tangential problem of how to effectively manage a heap.</p><p>So in the end there were programmers with these little 8-bit machines outperforming minicomputers costing hundreds of thousands of dollars.</p><p>That ends the first story.</p><p>When I first started programming the Macintosh, right after the switch to PowerPC processors in the mid-1990s, I was paranoid about system calls.  I knew the system memory allocation routines were unpredictable and should be avoided in performance-oriented code.  I'd noticeably sped up a commercial application by dodging a system "Is point in an arbitrarily complex region?" function. It was in this mindset that I decided to steer clear of Apple's BlockMove function--the MacOS equivalent of memcpy--and write my own.</p><p>The easy way to write a fast memory copier is to move as much data at a time as possible. 32-bit values are better than 8-bit values.  The problem with using 32-bit values exclusively is that there are alignment issues.  If the source address isn't aligned on a four-byte boundary, it's almost as bad as copying 8-bits at a time.  BlockMove contained logic to handle misaligned addresses, breaking things into two steps: individual byte moves until the source address was properly aligned, then 32-bit copies from that point on.  My plan was that if I always guaranteed that the source and destination addresses were properly aligned, then I could avoid all the special-case address checks and have a simple loop reading and writing 32-bits at a time.</p><p>(It was also possible to read and write 64-bit values, even on the original PowerPC chips, using 64-bit floating point registers.  But even though this looked good on paper, floating point loads and stores had a slightly longer latency than integer loads and stores.)</p><p>I had written a very short, very concise aligned memory copy function, one that clearly involved less code than Apple's BlockMove.</p><p>Except that BlockMove was faster.  Not just by a little, but <b>30%</b> faster for medium to large copies.</p><p>I eventually figured out the reason for this by disassembling BlockMove.  It was even more convoluted than I expected in terms of handling alignment issues.  It also had a check for overlapping source and destination blocks--more bloat from my point of view.  But there was a nifty trick in there that I never would have figured out on my own.</p><p>Let's say that a one megabyte block of data is being copied from one place to another. During the copy loop the data at the source and destination addresses is constantly getting loaded into the cache, 32 bytes at a time (the size of a cache line on early PowerPC chips), two megabytes of cache loads in all.</p><p>If you think about this, there's one flaw: all the data from the destination is loaded into the cache...<i>and then it's immediately overwritten by source data</i>.  BlockMove contained code to align addresses to 32 byte cache lines, then in the inner copy loop used a special instruction to avoid loading the destination data, setting an entire cache line to zeros instead.  For every 32 bytes of data, my code involved two cache line reads and one cache line write.  The clever engineer who wrote BlockMove removed one of these reads, resulting in a 30% improvement over my code.  This is even though BlockMove was pages of alignment checks and special cases, instead of my minimalist function.</p><p>There you go: one case where simpler was clearly better, and one case where it wasn't.</p><p class="s"><a href="9.html" id="perm">permalink</a> <i>December 8, 2007</i></p><h1>previously</h1><ul><li><a href=8.html>Deriving Forth</a><li><a href=7.html>Trapped! Inside a Recursive Data Structure</a><li><a href=6.html>Sending Modern Languages Back to 1980s Game Programmers</a><li><a href=5.html>Erlang as a Target for Imperative DSLs</a><li><a href=4.html>Follow-up to "Admitting that Functional Programming Can Be Awkward"</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>