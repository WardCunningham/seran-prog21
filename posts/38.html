<!DOCTYPE html><html lang="en"><head><title>Puzzle Languages</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Puzzle Languages</h1><p>I know I've covered this before.  I am repeating myself.  But it was woven into various other topics, never stated outright:</p><blockquote><p>Some programming languages, especially among those which haven't gained great popularity, are puzzles.</p></blockquote><p>That's not to be confused with "programming in general is a puzzle." There's always a certain amount of thought that goes into understanding a problem and deciding upon an approach to solving it.  But if it takes focused thought to phrase that solution into working code, you go down one path then back up, then give up, then try something completely different--then you're almost certainly using a puzzle language.</p><p>These are puzzle languages:</p><pre>Haskell
Erlang
Forth
J</pre><p>And these are not:</p><pre>Python
Ruby
Lua
C</pre><p>In Forth, the <a href="33.html">puzzle</a> is how to simplify a problem so that it can be mapped cleanly to the stack.  In Haskell and Erlang, the puzzle is how to manage with single assignment and without being able to reach up and out of the current environment.  In J the puzzle is how to phrase code so that it operates on large chunks of data at once.</p><p>Compare this to, say, Python.  I can usually bang out a solution to just about anything in Python.  I update locals and add globals and modify arrays and get working code.  Then I go back and clean it up and usually end up with something simpler.  In Erlang, as much as I want to deny it, I usually pick a direction, then realize I'm digging myself into a hole, so I scrap it and start over, and sometimes when I end up with a working solution it feels too fragile, something that wouldn't survive minor changes in the problem description.  (Clearly this doesn't apply to easy algorithms or simple transformations of data.)</p><p>A critical element of puzzle languages is providing an escape, a way to admit that the pretty solution is elusive, and it's time to get working code regardless of aesthetics.  It's interesting that these escapes tend to have a stigma; they induce a feeling of doing something wrong; they're guaranteed to result in pedantic lecturing if mentioned in a forum.</p><p>In Forth, an easy pressure value when the stack gets too busy is to use local variables.  Local variables have been historically deemed unclean by a large segment of the Forth community (although it's amazing how easy some Forth problems are if you use locals).  There's a peculiar angst involved in avoiding locals, even if they clearly make code simpler.  Locals aside, there's always the escape of using some additional global variables instead of stack juggling, which has a similarly bad reputation (even though everyone still does it).</p><p>In Erlang, ETS tables and the process dictionary are two obvious escapes.  And as expected, any mention of the process dictionary always includes the standard parental warning about the dangers of playing darts or standing there with the refrigerator door open.  It <b>is</b> handy, as shown by the standard library random number generator (which stores a three element tuple under the name <code>random_seed</code>), and <a href="http://www.wings3d.com">Wings3D</a> (which uses the process dictionary to keep track of GUI state).</p><p>A more interesting escape in Erlang is the process.  A process is commonly thought of as a mechanism of concurrency, but that need not be the case.  It's easy to make an infinite loop by having a tail recursive function.  Parameters in such a loop can be--if you <a href="1.html">dig into the implementation a bit</a>--directly modified, providing a safe and interesting blurring of functional and imperative code.  Imagine taking such a function and spawning it into its own process.  Each process captures a bit of relevant data in a small, endlessly recursive loop.  Imagine dozens or hundreds of these processes, each spinning away, holding onto important state data.  Erlang string theory, if you will.</p><p>I wouldn't want to break a program into hundreds of processes simply to capture state, but usually there are some important bits which are used and updated across a project.  Pulling these out of the purely functional world can be enough of a relief from growing complexity that the rest of the code can remain pure.</p><p>But there's still that stigma of doing something dirty.  Back before the Norton name became associated with anti-virus products, when MS-DOS was ubiquitous, Peter Norton authored the standard book on programming IBM PCs.  In a discussion of the MS-DOS interrupts for displaying characters and moving the cursor, he strongly advised that programmers not access video memory directly, but use the provided services instead. (The theory being that the MS-DOS interrupts would remain compatible on future hardware.)  Of course almost every application and game would not have been possible had developers taken Peter's advice to heart.  Learning to write directly to video memory was practically a cottage industry until Windows 95 finally ended the MS-DOS era.</p><p>Sometimes advice is too idealistic to follow.</p><p class="s"><a href="38.html" id="perm">permalink</a> <i>February 7, 2009</i></p><h1>previously</h1><ul><li><a href=37.html>Revisiting "Purely Functional Retrogames"</a><li><a href=36.html>Accidentally Introducing Side Effects into Purely Functional Code</a><li><a href=35.html>Timidity Does Not Convince</a><li><a href=34.html>Macho Programming</a><li><a href=33.html>Understanding What It's Like to Program in Forth</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>