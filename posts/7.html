<!DOCTYPE html><html lang="en"><head><title>Trapped! Inside a Recursive Data Structure</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Trapped! Inside a Recursive Data Structure</h1><p>Flat lists are simple.  That's what list comprehensions are designed to work with, for example.  Code for scanning or transforming a flat list can usually be tail recursive.  Once data becomes <i>deep</i>, where elements of a list can contain other lists <i>ad infinitum</i> something changes. It's trivial to iterate over a deep list; any basic Scheme textbook covers this early on.  You recurse down, down, down, counting up values, building lists, and then....trapped.  You're way down inside a function, and all you really want to do is exit immediately or record some data that applies to the whole nested data structure and keep going, but you can't.</p><p>As an example, here's the standard "is X contained in a list?" function written in Erlang:</p><pre>member(X, [X|_]) -&gt; true;
member(X, [_|T]) -&gt; member(X, T);
member(_, [])    -&gt; false.</pre><p>Once a match is found, that's it. A value of true is returned. A function to find X in a deep list takes a bit more work:</p><pre>member(X, [X|_]) -&gt;
   true;
member(X, [H|T]) when is_list(H) -&gt;
   case member(X, H) of
      true -&gt; true;
      _    -&gt; member(X, T)
   end;
member(X, [_|T]) -&gt;
   member(X, T);
member(X, []) -&gt;
   false.</pre><p>The ugly part here is that you could be down 50 levels in a deep list when a match is found, but you're trapped.  You can't just immediately stop the whole operation and say "Yes! Done!" You've got to climb back up those 50 levels.  That's the reason for checking for "true" in the second function clause.  Now this example is mild in terms of claustrophobic trappage, but it can be worse, and you'll know it when you run into such a case.</p><p>There are a couple of options here.  One is to throw an exception.  Another is to use continuation passing style.  But there's a third approach which I think is cleaner: manage a stack yourself instead of using the function call stack.  This keeps the function tail recursive, making it easy to exit or handle counters or accumulators across the whole deep data structure.</p><p>Here's <code>member</code> for deep lists written with an explicit stack:</p><pre>member(X, L) -&gt; member(X, L, []).
member(X, [X|_], _Stack) -&gt;
   true;
member(X, [H|T], Stack) when is_list(H) -&gt;
   member(X, H, [T|Stack]);
member(X, [_|T], Stack) -&gt;
   member(X, T, Stack);
member(_, [], []) -&gt;
   false;
member(X, [], [H|T]) -&gt;
   member(X, H, T).</pre><p>Whenever the head of the list is a list itself, the tail is pushed onto Stack so it can be continued with later, and the list is processed.  When there's no more input, check to see if Stack has any data on it.  If so, pop the top item and make it the current list.  When a match is found, the exit is immediate, because there aren't any truly recursive calls to back out of.</p><p>Would I really write <code>member</code> like this?  Probably not.  But I've found more complex cases where this style is much less restrictive than writing a truly recursive function.  One of the signs that this might be useful is if you're operating across a deep data structure <i>as a whole</i>.  For example, counting the number of atoms in a deep list.  Or taking a deep data structure and transforming into into one that's flat.</p><p class="s"><a href="7.html" id="perm">permalink</a> <i>December 1, 2007</i></p><h1>previously</h1><ul><li><a href=6.html>Sending Modern Languages Back to 1980s Game Programmers</a><li><a href=5.html>Erlang as a Target for Imperative DSLs</a><li><a href=4.html>Follow-up to "Admitting that Functional Programming Can Be Awkward"</a><li><a href=3.html>Admitting that Functional Programming Can Be Awkward</a><li><a href=2.html>On the Perils of Benchmarking Erlang</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>