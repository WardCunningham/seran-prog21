<!DOCTYPE html><html lang="en"><head><title>Macho Programming</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Macho Programming</h1><p>Back before I completely lost interest in debates about programming topics, I remember reading an online discussion that went like this:</p><p><b>Raving Zealot:</b> Garbage collection is FASTER than manual memory management!</p><p><b>Experienced Programmer:</b> You mean that garbage collection is faster than using <code>malloc</code> and <code>free</code> to manage 
a heap.  You can use pools and static allocation, and they'll be faster and more predictable than garbage collection.</p><p><b>Raving Zealot:</b> You need to get over your attitude that programming is a MACHO and RECKLESS endeavor!  If you use a garbage collected language, NOTHING can go wrong.  You're PROTECTED from error, and not reliant on your MACHONESS.</p><p>What struck me about this argument, besides that people actually argue about such things, is how many other respected activities don't have anywhere near the same level of paranoia about protection from mistakes.  On the guitar--or any musical instrument--you can play any note at any time, even if it's out of key or, more fundamentally, not played correctly (wrong finger placement or pressure or accidentally muting the string).  And people play instruments live, in-concert in front of thousands of people this way, knowing that the solo is improvised in Dorian E, and there's no physical barrier preventing a finger from hitting notes that aren't in that mode.  The same goes for sculpting, or painting, or carpentry...almost anything that requires skill.</p><p>(And building chickadee houses isn't universally considered a MACHO hobby, even though it involves the use of POWER TOOLS which can LOP OFF FINGERS.)</p><p>In these activities, mistakes are usually obvious and immediate: you played the wrong note, you cut a board to the wrong length, there's blood everywhere.  In macho programming, a mistake can be silent, only coming to light when there's a crash in another part of the code--even days later--or when the database gets corrupted.  Stupidly trivial code can cause this, like:</p><pre>array[index] = true;</pre><p>when <code>index</code> is -1.  And yet with this incredible potential for error, people still build operating systems and giant applications and massively multiplayer games in C and C++.  Clearly there's a lot of machoness out there, or it's simply that time and debugging and testing--and the acceptance that there will be bugs--can overcome what appear to be technical impossibilities.  It's hand-rolling matrix multiplication code for a custom digital signal processor vs. "my professor told me that assembly language is impossible for humans to use."</p><p>Would I prefer to ditch all high-level improvements, in exchange for programming being the technical equivalent of rock climbing?  NO!  You can romanticize it all you want, but when I wrote 8-bit games I clearly remember thinking how much more pleasant it was to tinker in BASIC than to spend hours coding up some crazy 6502 code that would lock-up the entire computer time after time (the bug would be that changing a loop index from 120 to 130 made it initially be negative, so the loop would end after one iteration, or some other obscurity).</p><p>What both this retro example and the C one-liner have in common is that the core difficulty stems less from the language itself than because code is being turned loose directly on hardware, so crashes are really crashes, and the whole illusion that your source code is actually the program being executed disappears.  Problems are debugged at the hardware level, with data breakpoints and trapped CPU exceptions and protected memory pages (this is how debuggers <i>work</i>).</p><p>It's a project suitable as part of a single semester undergraduate class to write an interpreter for your favorite low-level language.  Write it in Scheme or Erlang or Scala.  Use symbolic addresses, not a big array of integers, to represent memory.  Keep track of address offsets, instead of doing the actual math.  Have functions return lists of memory addresses that have been read from or modified.  Keep everything super simple and clean.  The goal is to be able to enter expressions or functions and see how they behave, which is a whole lot nicer than tripping address exceptions.</p><p>All of a sudden, even hardcore machine code isn't nearly so scary.  Write a dangerous function, get back a symbolic representation of what it did.  Mistakes are now simply wrong notes, provided you keep your functions small. It's still not easy, but macho has become safe.</p><p>(If you liked this, you might enjoy <a href="6.html">Sending Modern Languages Back to 1980s Game Programmers</a>.)</p><p class="s"><a href="34.html" id="perm">permalink</a> <i>August 30, 2008</i></p><h1>previously</h1><ul><li><a href=33.html>Understanding What It's Like to Program in Forth</a><li><a href=32.html>Kilobyte Constants, a Simple and Beautiful Idea that Hasn't Caught On</a><li><a href=31.html>Functional Programming Went Mainstream Years Ago</a><li><a href=30.html>Want to Write a Compiler? Just Read These Two Papers.</a><li><a href=29.html>A Spellchecker Used to Be a Major Feat of Software Engineering</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>