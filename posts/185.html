<!DOCTYPE html><html lang="en"><head><title>C is Lower Level Than You Think</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>C is Lower Level Than You Think</h1><p>Here's a bit of code that many new C programmers have written:</p><pre>for (int i = 0; i &lt; strlen(s); i++) {
    ...
}</pre><p>The catch is that <code>strlen</code> is executed in each iteration, and as it involves looking at every character in search of a null, it's an unintentional n-squared loop. The right solution is to assign the length of the string to a local variable before the loop and check that.</p><p>"That's just busywork," says our novice coder, "modern compilers are smart enough to do that kind of trivial optimization."</p><p>As it turns out, this is much trickier to automate than may first appear. It's only safe if it can be guaranteed that the body of the loop doesn't modify the string, and that guarantee in C is hard to come by. All bets are off after a single external function call, because memory used by the string could be referenced somewhere else and modified by that call. Most bets are off after a single store through a pointer inside the loop, because it could be pointing to the string passed to <code>strlen</code>. Actually, it's even worse than that: any time you write a value to memory you could be changing the value of any variable in memory. Determining that <code>a[i]</code> can be cached in a register across even a single memory write is unsolvable in the general case.</p><p>(To control the chaos, the C99 standard includes a way to assert that a pointer is used in a <a href="http://en.wikipedia.org/wiki/Restrict">restricted</a> manner. It's only an affirmation on the part of the programmer, and is not checked by the compiler. If you get this wrong the results are undefined.)</p><p>The GCC C compiler, as it turns out, will move the <code>strlen</code> call out of the loop in some cases. Don't get too excited, because now you've got an algorithm that's <a href="40.html">either n-squared or linear</a> depending on the compiler. You could also say the hell with all of this and write a naive optimizer that always lifts the <code>strlen</code> out of a for-loop expression. Great! It works in the majority of real-life cases. But now if you go and write an algorithm, even a contrived one, that's dependent on the string length changing inside the loop...uh oh, now the compiler is transforming your valid intent into code that doesn't work. Do you want this kind of nonsense going on behind the scenes?</p><p>The clunky "manually assign the length to a constant" solution is a better one across the board. You're clearly stating that it doesn't matter what external functions do or that there are other writes to memory. You've already grabbed the value you want and that's that.</p><p>(If you liked this, you might enjoy <a href="179.html">How much memory does malloc(0) allocate?</a>)</p><p class="s"><a href="185.html" id="perm">permalink</a> <i>November 25, 2013</i></p><h1>previously</h1><ul><li><a href=184.html>Three Years in an Alternate Universe</a><li><a href=183.html>What Are You The World's Foremost Authority Of?</a><li><a href=182.html>Dynamic Everything Else</a><li><a href=181.html>Why Do Dedicated Game Consoles Exist?</a><li><a href=180.html>Purely Functional Photoshop</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>