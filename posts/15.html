<!DOCTYPE html><html lang="en"><head><title>Why Garbage Collection Paranoia is Still (sometimes) Justified</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Why Garbage Collection Paranoia is Still (sometimes) Justified</h1><p><i>"As new code was compiled, older code (and other memory used by the compiler) was orphaned, eventually causing the PC to run low on free memory. A slow garbage collection process would automatically occur when available memory became sufficiently low, and the compiler would be unresponsive until the process had completed, sometimes taking as long as 15 minutes."</i></p><p style="text-align:right">&mdash;Naughty Dog's Jak and Daxter post-mortem</p><p>I know the title will bait people who won't actually read any of this article, so I'll say it right up front to make them feel the error of their reactionary ways: I am pro garbage collection.  It has nothing to do with manual memory management supposedly being too hard (good grief no).  What I like is that it stops me from thinking about trivial usage of memory <i>at all</i>.  If it would be more convenient to briefly have a data structure in a different format, I just create a new version transformed the way I want it.  Manually allocating and freeing these insignificant bits of memory is just busywork.</p><p>That's hardly a bold opinion in 2008.  There are more programming languages in popular use with garbage collection than there are without.  Most of the past paranoia about garbage collection slowness and pauses has been set aside in favor of increased productivity.  Computers have gotten much faster.  Garbage collectors have gotten better.  But those old fears are still valid, those hitches and pauses still lurking, and not just in the same vague way that some people like to assume that integer division is dog slow even on a 3GHz processor.  In fact, they apply to every garbage collected language implementation in existence.  Or more formally:</p><p><i>In any garbage collector, there exists some pathological case where the responsiveness of your program will be compromised.</i></p><p>"Responsiveness" only matters for interactive applications or any program that's vaguely real-time.  In a rocket engine monitoring system, responsiveness may mean "on the order of a few microseconds."  In a robotic probe used for surgery, it might be "on the order of four milliseconds."  For a desktop application, it might be in the realm of one to two seconds; beyond that, users will be shaking the mouse in frustration.</p><p>Now about the "pathological case." This is easy to prove.  In a garbage collector, performance is always directly proportional to <i>something</i>.  It might be total number of memory allocations.  It might be the amount of live data.  It might be something else.  For the sake of discussion let's assume it's the amount of live data.  Collection times might be acceptable for 10MB of live data, maybe even 100MB, but you can always come up with larger numbers: 250MB...or 2GB.  Or in a couple of years, 20GB. No matter what you do, at some point the garbage collector is going to end up churning through those 250MB or 2GB or 20GB of data, and you're going to <i>feel</i> it. </p><p>Ah, but what about generational collectors? They're based on the observation that most objects are short lived, so memory is divided into a nursery for new allocations and a separate larger pool for older data (or even a third pool for grandfatherly data).  When the nursery is full, live data is promoted to the larger pool.  These fairly cheap nursery collections keep happening, and that big, secondary pool fills up a little more each time.  And then, somewhere, sometime, the old generation fills up, all 200MB of it. This scheme has simply delayed the inevitable.  The monster, full-memory collection is still there, waiting for when it will strike.</p><p>What about real time garbage collection? More and more, I'm starting to see this as a twist on the myth of the <a href="http://c2.com/cgi/wiki?SufficientlySmartCompiler">Sufficiently Smart Compiler</a>. If you view "real time" as "well engineered and fast," then it applies to most collectors in use, and they each still have some point, somewhere down the road, at which the pretense of being real time falls apart. The other interpretation of real time is some form of incremental collection, where a little bit of GC happens here, a little bit there, and there's never a big, painful pause.</p><p>An interesting question is this: What language systems in existence are using a true incremental or concurrent garbage collector? I know of three: Java, Objective C 2.0 (which just shipped with OS X Leopard), and the .net runtime. Not Haskell. Not Erlang. Not Objective Caml [EDIT: The OCaml collector for the second generation is <a href="http://caml.inria.fr/pub/old_caml_site/ocaml/speed.html">incremental</a>]. Not any version of Lisp or Scheme. Not Smalltalk. Not Ruby. That begs a lot of questions. Clearly incremental and concurrent collection aren't magic bullets or they'd be a standard part of language implementations. Is it that the additional overhead of concurrent collection is only worthwhile in imperative languages with lots of frequently modified, cross-linked data? I don't know.</p><p>Incremental collection is a trickier problem than it sounds.  You can't just look at an individual object and decide to copy or free it.  In order to know if a data object is live or not, you've got to scan the rest of the world. The incremental collectors I'm familiar with work that way: they involve a full, non-incremental marking phase, and then copying and compaction are spread out over time.  This means that the expense of such a collector is proportional to the amount of data that must be scanned during the marking phase and as such has a lurking pathological case.</p><p>Does knowing that garbage collectors break down at some point mean we should live in fear of them and go back to manual heap management?  Of course not.  But it does mean that some careful thought is still required when it comes to dealing with very large data sets in garbage collected languages.</p><p><b>Next time:</b> A look at how <a href="16.html">garbage collection works in Erlang</a>.  The lurking monster is still there, but there are some interesting ways of delaying his attack.</p><p class="s"><a href="15.html" id="perm">permalink</a> <i>January 5, 2008</i></p><h1>previously</h1><ul><li><a href=14.html>Functional Programming Archaeology</a><li><a href=13.html>Would You Bet $100,000,000 on Your Pet Programming Language?</a><li><a href=12.html>Timings and the Punchline</a><li><a href=11.html>Revisiting "Programming as if Performance Mattered"</a><li><a href=10.html>Finally: Data Structure Constants in Erlang</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>