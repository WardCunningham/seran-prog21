<!DOCTYPE html><html lang="en"><head><title>How I Learned to Stop Worrying and Love Erlang's Process Dictionary</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>How I Learned to Stop Worrying and Love Erlang's Process Dictionary</h1><p>The rise of languages based upon hash tables is one of the great surprises in programming over the last twenty years.</p><p>Whatever you call them--hash tables, dictionaries, associative arrays, hash maps--they sure are useful. A majority of my college data structures courses are immediately negated. If you've got pervasive hash table support, then you've also got arrays (just hash tables with integer keys), growable arrays (ditto), sparse arrays (again, same thing), and it's rare to have to bother with binary trees, red-black trees, tries, or anything more complex. Okay, sets are still useful, but they're hash tables where only the keys matter. I'd even go so far as to say that with pervasive hash table support it's unusual to spend time thinking about data structures at all. It's key/value pairs for everything. (And if you need convincing, study Peter Norvig's <a href="http://norvig.com/sudoku.html">Sudoku solver</a>.)</p><p>If you don't believe the theory that <a href="http://prog21.dadgum.com/31.html">functional programming went mainstream years ago</a>, then at least consider that the mismatch between dictionary-based programming and functional programming has dealt a serious blow to the latter.</p><p>Now, sure, it's <i>easy</i> to build a purely functional dictionary in Erlang or Haskell. In fact, such facilities are already there in the standard libraries. It's <i>using</i> them that's clunky. Reading a value out of a dictionary is straightforward enough, but the restrictions of single-assignment, and that "modifying" a hash table returns a new version, calls for a little <a href="http://prog21.dadgum.com/38.html">puzzle</a> solving.</p><p>I can write down any convoluted sequence of dictionary operations:</p><blockquote><p>Add the value of the keys "x" and "y" and store them in key "z". If "z" is greater than 100, then also set a key called "overflow" and add the value of "extra" to "x." If "x" is greater than 326, then set "finished" to true, and clear "y" to  zero.</p></blockquote><p>and in Python, Ruby, Lua, or Perl, minimal thought is required to write out a working solution. It's just a sequence of operations that mimic their textual descriptions. Here's the Python version, where the dictionary is called "d":</p><pre>d['z'] = d['x'] + d['y']
if d['z'] &gt; 100:
   d['overflow'] = True
   d['x'] += d['extra']
if d['x'] &gt; 326:
   d['finished'] = True
   d['y'] = 0</pre><p>I can certainly write the Erlang version of that (and, hey, atoms, so no quotes necessary!), but I can't do it so mindlessly. (Go ahead and try it, using either the <code>dict</code> or <code>gb_trees</code> modules.) I may be able to come up with Erlang code that's prettier than Python in the end, but it takes more work, and a minor change to the problem definition might necessitate a full restructuring of my solution.</p><p>Well, okay, no, the previous paragraph isn't true at all. I can bang-out an Erlang version that closely mimics the Python solution. And as a bonus, it comes with the big benefit of Erlang: the hash table is completely isolated inside of a single process. All it takes is getting over the psychological hurdle--and the lecturing from purists--about using the process dictionary. (You can use the <a href="http://www.erlang.org/doc/man/ets.html">ets module</a> to reach the same end, but it takes more effort: you need to create the table first, and you have to create and unpack key/value pairs yourself, among other quirks.)</p><p>Let me come right out and say it: it's okay to use the process dictionary.</p><p>Clearly the experts agree on this, because every sizable Erlang program I've looked at makes use of the process dictionary. It's time to set aside the rote warnings of how unmaintainable your code will be if you use <code>put</code> and <code>get</code> and instead revel in the usefulness of per-process hash tables. Now what's <i>really</i> being preached against, when the horrors of the process dictionary are spewed forth, is using it as a way to sidestep functional programming, weaving global updates and flags through your code like old-school BASIC. But that's the extreme case. Here's a list of situations where I've found the process dictionary to be useful, starting from the mildest of instances:</p><p><b>Low-level, inherently stateful functions.</b> Random number generation is the perfect example, and not too surprisingly the seed that gets updated with each call lives in the process dictionary.</p><p><b>Storing process IDs.</b> Yes, you can use named processes instead, and both methods keep you from having to pass PIDs around, but named processes are global to the entire Erlang node. Use the process dictionary instead and you can start multiple instances of the same application without conflict.</p><p><b>Write-once process parameters</b>. Think of this as an initial configuration step. Stuff all the settings that will never change within a process in the dictionary. From a programming point of view they're just like constants, so no worries about side effects.</p><p><b>Managing data in a tail recursive server loop.</b> If you done any Erlang coding you've written a tail-recursive server at some point. It's a big <code>receive</code> statement, where each message handling branch ends with a recursive call. If there are six parameters, then each of those calls involves six parameters, usually with one of them changed. If you add a new parameter to the function, you've got to find and change each of the recursive calls. Eventually it makes more sense to pack everything into a data structure, like a <code>gb_tree</code> or <code>ets</code> table. But there's nothing wrong with just using the simpler process dictionary for key/value pairs. It doesn't always make sense (you might want the ability to quickly roll back to a previous state), but sometimes it does.</p><p><b>Handling tricky data flow in high-level code.</b> Sometimes trying to be pure is messy. Nice, clean code gets muddled by having to pass around some data that only gets used in exceptional circumstances. All of a sudden functions have to return tuples intead of simple values. All of a sudden there's tangential data hitchhiking through functions, not being used directly. And when I start going down this road I find myself getting frustrated and annoyed, jumping through hoops to do something that I wouldn't even care about in most languages. Making flags or key elements of data globally accessible, is a huge sigh of relief, and the excess code melts away.</p><p>(If you've read this and are horrified that I'm completely misunderstanding functional programming, remember that I've gone <a href="23.html">further down</a> the functional path than most people for what appear to be state-oriented problems.) </p><p class="s"><a href="53.html" id="perm">permalink</a> <i>December 9, 2009</i></p><h1>previously</h1><ul><li><a href=52.html>Slow Languages Battle Across Time</a><li><a href=51.html>How Did Things Ever Get This Good?</a><li><a href=50.html>Tales of a Former Disassembly Addict</a><li><a href=49.html>Micro-Build Systems and the Death of a Prominent DSL</a><li><a href=48.html>The World's Most Mind-Bending Language Has the Best Development Environment</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>