<!DOCTYPE html><html lang="en"><head><title>Timings and the Punchline</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Timings and the Punchline</h1><p>I forgot two things in <a href="11.html">Revisiting "Programming as if Performance Mattered"</a>: exact timings of the different versions of the code and a punchline.  I'll do the timings first.</p><p><code>timer:tc</code> falls apart once code gets too fast.  A classic sign of this is running consecutive timings and getting back a sequence of numbers like 15000, 31000, 31000, 15000.  At this point you should write a loop to execute the test function, say, 100 times, then divide the total execution time by 100.  This smooths out interruptions for garbage collection, system processes, and so on.</p><p>And now the timings (lower is better).  The TGA image decoder with the clunky binary / list / binary implementation of <code>decode_rgb</code>, on the same sample image I used in 2004:</p><pre>16,720 microseconds</pre><p>(Yes, this is larger than the original 15,000 I reported, because it's an average, not the result of one or two runs.) The recursive version operating directly on binaries:</p><pre>18,700 microseconds</pre><p>The ultra-slick version using binary comprehensions:</p><pre>22,600 microseconds</pre><p>I think the punchline is obvious at this point.</p><p>Were I using this module in production code, I'd do one of three things. If I'm only decoding a handful of images here and there, then this whole discussion is irrelevant.  The Erlang code is more than fast enough.  If image decoding is a huge bottleneck, I'd move the hotspot, <code>decode_rgb</code> into a small linked-in driver.  Or, and the cries of cheating may be justified here, I'd remove <code>decode_rgb</code> completely.</p><p>Remember, transparent pixels runs at the start and end of each row are already detected elsewhere.  <code>decode_rgb</code> blows up the runs in the middle from 24-bit to 32-bit.  At some point this needs to be done, but it may just be that it doesn't need to happen at the Erlang level at all.  If the pixel data is passed off to another non-Erlang process anyway, maybe for rendering or for printing or some other operation, then there's no reason the compressed 24-bit data can't be passed off directly.  That fits the style I've been using for this whole module, of operating on compressed data without a separate decompression step.</p><p>But now we're getting into useless territory: quibbling over microseconds without any actual context.  You can't <i>feel</i> the difference between any of the optimized versions of the code I presented last time, and so it doesn't matter.</p><p class="s"><a href="12.html" id="perm">permalink</a> <i>December 21, 2007</i></p><h1>previously</h1><ul><li><a href=11.html>Revisiting "Programming as if Performance Mattered"</a><li><a href=10.html>Finally: Data Structure Constants in Erlang</a><li><a href=9.html>Two Stories of Simplicity</a><li><a href=8.html>Deriving Forth</a><li><a href=7.html>Trapped! Inside a Recursive Data Structure</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>