<!DOCTYPE html><html lang="en"><head><title>Purely Functional Retrogames, Part 4</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Purely Functional Retrogames, Part 4</h1><p>(Read <a href="23.html">Part 1</a> if you missed it.)</p><p>By the definition of functional programming, functions can't access any data that isn't passed in.  That means you need to think about what data is needed for a particular function, and "thread" that data through your program so a function can access it.  It sounds horrible when written down, but it's easy in practice.</p><p>In fact, just working out the data dependencies in a simple game is an eye-opening exercise.  It usually turns out that there are far fewer dependencies than you might imagine.  In Pac-Man, there's an awful lot of state that makes no difference to how the ghosts move: the player's score, whether the fruit is visible or not, the location of dots in the maze.  Similarly, the core movement of Pac-Man, ignoring collision detection, only relies on a handful of factors: the joystick position, the location of walls in the maze (which are constant, because there's only one maze), and the current movement speed (which increases as mazes are completed).</p><p>That was the easy part.  The tricky bit is how to handle functions that affect the state of the world.  Now of course a function doesn't actually change anything, but somehow those effects on the world need to be passed back out so the rest of the game knows about them.  The "move Pac-Man" routine returns the new state of Pac-Man (see <a href="25.html">Part 3</a> for more about how entity state is represented).  If collision detection is part of the "move Pac-Man" function, then there are more possible changes to the world: a dot has been eaten, a power pill has been eaten, fruit has been eaten, Pac-Man is dead (because of collision with a non-blue ghost), a ghost is dead (because of a collision with a powered-up Pac-Man).</p><p>When I first mused over writing a game in a purely functional style, this had me stymied.  One simple function ends up possibly changing the entire state of the world?  Should that function take the whole world as input and return a brand new world as output?  Why even use functional programming, then?</p><p>A clean alternative is not to return new versions of anything, <i>but to simply return statements about what happened</i>.  Using the above example, the movement routine would return a list of any of these side effects:</p><pre>{new_position, Coordinates}
{ate_ghost, GhostName}
{ate_dot, Coordinates}
ate_fruit
killed_by_ghost</pre><p>All of a sudden things are a lot simpler.  You can pass in the relevant parts of the state of the world, and get back a simple list detailing what happened.  Actually <b>handling</b> what happened is a separate step, one that can be done later on in the frame.  The advantage here is that changes to core world data don't have to be painstakingly threaded in and out of all functions in the game.</p><p>I'd like to write some concluding thoughts on this series, to answer the "Why do this?" and "What about Functional Reactive Programming?" questions--among others--but wow I've already taken just about a month for these four short entries, so I'm not going to jump into that just yet.</p><p>(I eventually wrote the <a href="37.html">follow-up</a>.)</p><p class="s"><a href="26.html" id="perm">permalink</a> <i>May 11, 2008</i></p><h1>previously</h1><ul><li><a href=25.html>Purely Functional Retrogames, Part 3</a><li><a href=24.html>Purely Functional Retrogames, Part 2</a><li><a href=23.html>Purely Functional Retrogames, Part 1</a><li><a href=22.html>My Road to Erlang</a><li><a href=21.html>Slumming with BASIC Programmers</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>