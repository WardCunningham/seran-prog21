<!DOCTYPE html><html lang="en"><head><title>Slow Languages Battle Across Time</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Slow Languages Battle Across Time</h1><p>In my previous <a href="51.html">optimistic outburst</a> I asserted that "Even a language like Ruby, which tends to hang near the bottom of any performance-oriented benchmark, is thousands of times faster than BASICs that people were learning to program 8-bit home computers with in the 1980s." That was based on some timings I did five years ago, so I decided to revisit them.</p><p>The benchmark I used is the old and not-very-good-as-a-benchmark Sieve of Eratosthenes, because that's the only benchmark that I have numbers for in <a href="http://en.wikipedia.org/wiki/Atari_BASIC">Atari BASIC</a> on original 8-bit computer hardware. Rather than using Ruby as the modern-day language, I'm using Python, simply because I already have it installed. It's a fair swap, as Python doesn't have a reputation for performance either.</p><p>The sieve in Atari BASIC, using timings from an <a href="http://www.cyberroach.com/analog/an16/action.htm">article written in 1984</a> by <a href="http://www.dadgum.com/halcyon/BOOK/MORIARTY.HTM">Brian Moriarty</a>, clocks in at:</p><pre>324 seconds (or just under 5 and a half minutes)</pre><p>The Python version, running on hardware that's a generation back--no i7 processor or anything like that--completes in:</p><pre>3 seconds</pre><p>Now that's impressive! A straight-ahead interpreted language, one with garbage collection and dynamic typing and memory allocation all over the place, and it's still two orders of magnitude, 108 times, faster than what hobbyist programmers had to work with twenty-five years ago. But what about the "thousands of times" figure I tossed about in the first paragraph?</p><p>Oh, yes, I forgot to mention that the Python code is running the full Sieve algorithm <b>one thousand times</b>.</p><p>If the Atari BASIC program ran a thousand times, it would finish after 324,000 seconds or 5400 minutes or almost four days. That means the Python version is--get ready for this--108,000 times faster than the Atari BASIC code.</p><p>That's progress.</p><p>(If you liked this, you might also like <a href="29.html">A Spellchecker Used to be a Major Feat of Software Engineering</a>.)</p><p class="s"><a href="52.html" id="perm">permalink</a> <i>November 14, 2009</i></p><h1>previously</h1><ul><li><a href=51.html>How Did Things Ever Get This Good?</a><li><a href=50.html>Tales of a Former Disassembly Addict</a><li><a href=49.html>Micro-Build Systems and the Death of a Prominent DSL</a><li><a href=48.html>The World's Most Mind-Bending Language Has the Best Development Environment</a><li><a href=47.html>A Personal History of Compilation Speed, Part 2</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>