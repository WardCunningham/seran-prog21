<!DOCTYPE html><html lang="en"><head><title>The UNIX Philosophy and a Fear of Pixels</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>The UNIX Philosophy and a Fear of Pixels</h1><p>I've finally crossed the line from mild discomfort with people who espouse the UNIX way as the pinnacle of computing to total befuddlement that there's anyone who still wants to argue such a position. One key plank in the UNIX party platform is that small tools can be combined together providing great expressiveness. Here's a simple task: print a list of all the files with a <code>txt</code> extension in the current directory except for <code>ignore_me.txt</code>.</p><p>Getting a list of text files is easy: <code>ls *.txt</code>. Now how to remove <code>ignore_me.txt</code> from that list? Hmmm...well, you might know that <code>grep</code> can be inverted via a switch so it returns lines that don't match:</p><pre>ls *.txt | grep -v ^ignore_me\\.txt$</pre><p>There's also the <code>find</code> utility which can do the whole thing in one step, but it takes more fiddling around to get the parameters right:</p><pre>find *.txt -type f ! -name ignore_me.txt</pre><p>This all works, and we've all figured this stuff out by reading man pages and googling around, but take a moment to consider how utterly anachronistic both of the above solutions come across to non-believers in 2012. It's like promoting punch cards or IBM's job control language from the 1960s. You've got to get that space between the <code>!</code> and <code>-name</code> or you'll get back "<code>!-name: event not found</code>." But this isn't what I wanted to talk about so I'll stop there.</p><p>What I really wanted to talk about are text files and visual programming.</p><p>I keep seeing the put-downs of any mention of programming that involves a visual component. I wrote an entire entry two years ago on the subject, <a href="82.html">This Isn't Another Quick Dismissal of Visual Programming</a>, and now I don't think it was strong enough. Maybe the problem is that "visual programming" is a bad term, and it should be "ways to make programming be more visual." At one time all coding was done on monochrome monitors, but inexpensive color displays and more CPU power led to syntax highlighting, which most developers will agree is a win.</p><p>Now go further and stop thinking of code as a long scroll of text, but rather as discrete functions that you can view and edit independently. That's starting to get interesting. Or consider the discussion of trees in any algorithms book, where nodes and leaves are rendered inside of boxes, and arrows show the connections between them. It's striking that $500 consumer hardware has over three million pixels and massively parallel GPUs to render those pixels, yet there's old school developer resistance to anything fancier than dumping out characters in a monospaced font? Why is that?</p><p>It's because tools to operate on text files are easy to write, and <a href="66.html">anything involving graphics is several orders of magnitude harder</a>. </p><p>Think about all the simple, interview-style coding problems you've seen. "Find all the phone numbers in this text file." <a href="http://imranontech.com/2007/01/24/using-fizzbuzz-to-find-developers-who-grok-coding/">FizzBuzz</a>. Do any of them involve colors or windows or UI? For example, "On this system, how many pixels wide is a given string in 18 point Helvetica Bold?" "List all the filenames in the current directory in alphabetical order, with the size of the font relative to the size of the file (the names of the largest and smallest files should be displayed in the largest and smallest font, respectively)."</p><p>There have been some tantalizing attempts at making graphical UI development as easy as working with text. I don't mean tools like Delphi or the iOS UIKit framework, where you write a bunch of classes that inherit from a core set of classes, then use visual layout packages to design the front-end. I mean tools that let you quickly write a description of what you want UI-wise, and then there it is on the screen. No OOP. No code generators. If you've ever used the Tk toolkit for Tcl, then you've got a small taste of what's possible.</p><p>The best attempt I've seen is the UI description sub-language of <a href="http://en.wikipedia.org/wiki/REBOL">REBOL</a>. Creating a basic window with labeled buttons is a one-liner. Clearly all wasn't perfect in REBOL-ville, as a burst of excitement in the late 1990s was tempered with a long period of inactivity, and some features of the language never quite lived up to their initial promises.</p><p>These days HTML is the most reasonable approach to anything involving fonts and images and interaction. It's not as beautifully direct as REBOL, and being trapped in a browser is somewhere between limiting and annoying, but the visual toolkit is there, and it's ubiquitous. (For the record, I would have solved the "list all the filenames..." problem by generating HTML, but firing up a browser to display the result is a heavy-handed solution.)</p><p>Code may still be text behind the scenes, but that doesn't mean that <i>coding</i> has to always be about working directly in a text editor or monospaced terminal window.</p><p class="s"><a href="159.html" id="perm">permalink</a> <i>December 9, 2012</i></p><h1>previously</h1><ul><li><a href=158.html>"Not Invented Here" Versus Developer Sanity</a><li><a href=157.html>An Outrageous Port</a><li><a href=156.html>OOP Isn't a Fundamental Particle of Computing</a><li><a href=155.html>The Background Noise Was Louder than I Realized</a><li><a href=154.html>Do You Really Want to be Doing This When You're 50?</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>