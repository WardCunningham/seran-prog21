<!DOCTYPE html><html lang="en"><head><title>Minimalism in an Age of Tremendous Hardware</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Minimalism in an Age of Tremendous Hardware</h1><p>You don't know minimalism until you've explored the history of the Forth programming language.</p><p>During Forth's heyday, it was unremarkable for a full development environment--the entire language with extensions, assembler, and integrated editor--to be less than 16K of object code. That's not 16K of data loaded by another program, but a full, standalone, 16K  system capable of meta-compiling its own source code to create a new standalone system.</p><p>With work, and depending on how much you wanted to throw out, you could get that 16K number much lower. 8K was reasonable. 1K for an ultralight system with none of the blanks filled in. Half that if you were an extremist that didn't mind bending the definition of Forth into unrecognizable shapes.</p><p>Some Forths booted directly from a floppy disk and took over the machine. No operating system necessary. Or perhaps more correctly, Forth <i>was</i> the operating system.</p><p>In the early 1990s, Forth creator Chuck Moore had an epiphany and decided that interactively hex-editing 32-bit x86 machine code was the way to go. (After writing an entire chip layout package this way he realized there were some drawbacks to the scheme and reverted to designing languages that used source code.)</p><p>Looking back, there are many questions. Was there ever a time when reducing a development environment from 16K to 8K actually mattered? Why did the Forth community expend so much effort gazing inward, constantly rethinking and rewriting the language instead of building applications that incidentally happened to be written in Forth? Why was there such emphasis on machine-level efficiency instead of developer productivity?</p><p>In 2012 it all seems like so much madness, considering that I could write a Forth interpreter in Lua that when running on an iPhone from a couple generations back would be 10,000 times faster than the most finely crafted commercial Forth of 30 years ago. I'm not even considering the tremendous hardware in any consumer-level desktop.</p><p>Still, there's something to the minimalism that drove that madness. The mental burden involved in working with a 50K file of Python code is substantially higher than one of 10K. It doesn't matter that these modest numbers are dwarfed by the multi-megabyte system needed to execute that code. Those hundreds of extra lines of Python mean there's more that can go wrong, more that you don't understand, more time sitting in front of a computer fixing and puzzling when you should be out hiking or playing guitar.</p><p>Usually--almost always--there's a much simpler solution waiting to be discovered, one that doesn't involve all the architectural noise, convolutions of the straightforward, and misguided emphasis on hooks and options for all kinds of tangents which might be useful someday. Discovering that solution may not be easy, but it is time well spent.</p><p>That's what I learned from Forth.</p><p>(If you liked this, you might enjoy <a href="8.html">Deriving Forth</a>.)</p><p class="s"><a href="151.html" id="perm">permalink</a> <i>September 18, 2012</i></p><h1>previously</h1><ul><li><a href=150.html>The Goal is to be Like a Bad Hacker Movie</a><li><a href=149.html>Hopefully More Controversial Programming Opinions</a><li><a href=148.html>All that Stand Between You and a Successful Project are 500 Experiments</a><li><a href=147.html>One Small, Arbitrary Change and It's a Whole New World</a><li><a href=146.html>App Store Failure and Personal Responsibility</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>