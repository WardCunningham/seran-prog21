<!DOCTYPE html><html lang="en"><head><title>Tips for Writing Functional Programming Tutorials</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Tips for Writing Functional Programming Tutorials</h1><p>With the growing interest in a functional programming style, there are more tutorials and blog entries on the subject, and that's wonderful. For anyone so inclined to write their own, let me pass along a few quick tips.</p><p><b>Decide if you're writing a tutorial about functional programming or a specific language.</b> If you're covering the feature set of Haskell, from the type system to laziness to monads, then you're writing about Haskell. If you show how to explore interesting problems and the executable parts of your tutorial happen to be written in Haskell, then you're writing about functional programming. See the difference?</p><p><b>Let types explain themselves.</b> The whole point of type inference is that it's behind the scenes and automatic, helping you write more correct code with less bookkeeping. Don't negate that benefit by talking about the type system explicitly. Let it be silently assimilated while working through interesting examples and exercises that have nothing to do with types.</p><p><b>Don't talk about currying.</b> There's a fascinating theoretical journey from a small set of expressions--the lambda calculus--to a more useful language. With just the barest of concepts you can do seemingly crazy things like recursion without named functions and using single-argument functions to mimic functions that take multiple arguments (a.k.a. currying). Don't get so swept up in that theory that you forget the obvious: in any programming language ever invented, there's <i>already</i> a way to easily define functions of multiple arguments. That you can build this up from more primitive features is not useful or impressive to non-theoreticians.</p><p><b>Make sure you've got meaningful examples.</b> If you have functions named <code>foo</code> or <code>bar</code>, then that's a warning sign right there. If you're demonstrating factorials or the Fibonacci sequence without a reason for calculating them (and there are reasons, such as permutations), then choose something else. There are curious and approachable problems <i>everywhere</i>. It's easy to write a <code>dog_years</code> function based on the incorrect assumption that one human year equals seven dog years. There's a more accurate computation where the first two years of a dog's life are 10.5 human years each, then each year after that maps to four human years. That's a perfect beginner-level problem.</p><p>(If you liked this, you might enjoy <a href="138.html">You, Too, Can Be on the Cutting Edge of Functional Programming Research</a>.)</p><p class="s"><a href="176.html" id="perm">permalink</a> <i>June 11, 2013</i></p><h1>previously</h1><ul><li><a href=175.html>Getting Comfortable with the Softer Side of Development</a><li><a href=174.html>Flickr's Redesign is a Series of Evolutionary Changes</a><li><a href=173.html>Stumbling Into the Cold Expanse of Real Programming</a><li><a href=172.html>A Short Quiz About Language Design</a><li><a href=171.html>Remembering a Revolution That Never Happened</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>