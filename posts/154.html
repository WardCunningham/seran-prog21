<!DOCTYPE html><html lang="en"><head><title>Do You Really Want to be Doing This When You're 50?</title><link rel="alternate" type="application/atom+xml" title="Atom feed" href="atom.xml"><meta name="viewport" content="width=device-width,initial-scale=1"><style>a,#p21{text-decoration:none}a:link{color:#00D}a:visited{color:purple}a:hover{text-decoration:underline}body,div{margin:0;padding:0;box-sizing:border-box}body{font:100%/1.5 verdana;color:#222}p,ul,blockquote,pre{margin:0 0 1em}ul{list-style:none;padding-left:1em;text-indent:-1em}h1,h2{font:700 1.27em verdana;margin:0 0 .5em}h1{color:#117}blockquote{font-style:italic}pre,code{font:700 1em "courier new",monospace}pre{overflow:auto}.box{margin:0 auto;padding:0 12px}.s{font:.91em/1.4 verdana}.ab a{display:block;margin:0 0 1em;padding-left:1em;text-indent:-1em}#top{background:#117;color:#FFF;margin:0 0 .67em;border:0 solid #7373D9;border-width:0 0 12px;padding:2em 0 0}#p21{font:700 2.5em georgia;color:#FFF}#perm{color:#222;background:#DDD;border:1px solid #BBB;padding:2px}@media screen and (min-width:768px){blockquote,pre{margin-left:1.25em}.box{max-width:840px}#c1{width:71%;float:left}#c2{width:26%;float:right}}</style></head><body><div id="top"><div class="box"><a id="p21" href="/">programming in&nbsp;the<br>twenty-first century</a><p>It's not about technology for its own sake. It's about being able to implement your ideas.</p></div></div><div class="box"><div id="c1"><h1>Do You Really Want to be Doing This When You're 50?</h1><p>When I was still a professional programmer, my office-mate once asked out of the blue, "Do you really want to be doing this kind of work when you're fifty?"</p><p>I have to say that made me stop and think.</p><p>To me, there's an innate frustration in programming. It doesn't stem from having to work out the solutions to difficult problems. That takes careful thought, but it's the same kind of thought a novelist uses to organize a story or to write dialog that rings true. That kind of problem-solving is satisfying, even fun.</p><p>But that, unfortunately, is not what most programming is about. It's about trying to come up with a working solution in a problem domain that you don't fully understand and don't have time to understand.</p><p>It's about skimming <a href="129.html">great oceans of APIs</a> that you could spend years studying and learning, but the market will have moved on by then and that's no fun anyway, so you cut and paste from examples and manage to get by without a full picture of the architecture supporting your app.</p><p>It's about reading between the lines of documentation and guessing at how edge cases are handled and whether or not your assumptions will still hold true two months or two years from now.</p><p>It's about the constant evolutionary changes that occur in the language definition, the compiler, the libraries, the application framework, and the underlying operating system, that all snowball together and keep you in maintenance mode instead of making real improvements. </p><p>It's about getting derailed by hairline fractures in otherwise reliable tools, and apparently being the first person to discover that a PNG image with four bits-per-pixel and an alpha channel crashes the decoder, then having to work around that.</p><p>One approach is to dig in and power through all the obstacles. If you're fresh out of school, there are free Starbucks lattes down the hall, and all your friends are still at the office at 2 AM, too...well, that works. But then you have to do it again. And again. It's always a last second skid at 120 miles per hour with brakes smoking and tires shredding that makes all the difference between success and failure, but you pulled off another miracle and survived to do it again.</p><p>I still like to build things, and if there's no one else to do it, then I'll do it myself. I keep improving the <a href="77.html">the tiny Perl script</a> that puts together this site, because that tiny Perl script is unobtrusive and reliable and lets me focus on writing. I have a handy little image compositing tool that's less than 28 kilobytes of C and Erlang source. I know how it works inside and out, and I can make changes to it in less time than than it takes to coax what I want out of ImageMagick.</p><p>But large scale, high stress coding? I may have to admit that's a young man's game.</p><p class="s"><a href="154.html" id="perm">permalink</a> <i>October 3, 2012</i></p><h1>previously</h1><ul><li><a href=153.html>Digging Out from Years of Homogeneous Computing</a><li><a href=152.html>What's Your Hidden Agenda?</a><li><a href=151.html>Minimalism in an Age of Tremendous Hardware</a><li><a href=150.html>The Goal is to be Like a Bad Hacker Movie</a><li><a href=149.html>Hopefully More Controversial Programming Opinions</a></ul></div><div id="c2"><h1><a href="archives.html">archives</a></h1><p><b><a href="https://twitter.com/dadgumjames">twitter</a></b> / <b><a href="mailto:james.hague@gmail.com">mail</a></b></p><div class="s"><p>I'm James Hague, a <a href="56.html">recovering programmer</a> who has been designing video games since the 1980s. <a href="195.html">Programming Without Being Obsessed With Programming</a> and <a href="177.html">Organizational Skills Beat Algorithmic Wizardry</a> are good starting points. For the older stuff, try the <a href="162.html">2012 Retrospective</a>.</p><p>Where are <a href="57.html">the comments</a>?</p></div></div></div>